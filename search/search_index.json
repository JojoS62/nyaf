{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"@nyaf is \"Not Yet Another Framework\" # And it is, well, just another framework. It's simple, has a flat learning curve, doesn't need any special tools. And it's 34KB zipped only, for all three parts together, of course. No dependencies! No bullshit! Pure HTML 5 DOM API and ES 2015 Code. Super small, super smart, super powerful. Period! Write frontend apps without the hassle of a complex framework, use the full power of HTML 5, keep a component based style. Elevator Pitch # Since the amazing impact of jQuery in 2006 we have seen an uncountable number of JavaScript frameworks. Some good, some nice, a few excellent. Each time has it's leading frameworks and an audience that loves it. The comes from simple properties. It should save time compared with programming on a basic level. It should give stability and reliability to your apps where things in the browser's internal parts get messy. And it adds another layer of indirection to make things smooth and good looking, nicely maintainable, and well architectured. But over time, frameworks get elder. And they can't change and involve, because they already have a broad audience and hundreds or thousands of projects rely on them. The manufacturer can't break everything to go the next step. The programmers get stuck. And the world of browser programming has evolved dramatically. Meanwhile, we have an amazingly powerful native API in HTML 5. One of the most important innovations in browser development where Web Components. The API is easy to learn, the support is complete for all modern browsers, and the implementation is stable. At the same time the programming language TypeScript come to us along with a powerful toolset. It's time for the next step. Take the leading tools and create an easy to use library, that covers the hard stuff and be invisible where the native API is almost the best. That's @NYAF. Parts # The library comes in three parts: A Core library that handles Web Components the easy way, provide a router for Single Page Apps, and adds a nice template language A Forms library that handles data binding and decorator based validation A Store library that gives your app a state engine using the common flux architecture style Everything else is simple HTML 5 API, without any restrictions. You can add CSS, other libraries, or your own stuff at almost any position.","title":"Home"},{"location":"#nyaf-is-not-yet-another-framework","text":"And it is, well, just another framework. It's simple, has a flat learning curve, doesn't need any special tools. And it's 34KB zipped only, for all three parts together, of course. No dependencies! No bullshit! Pure HTML 5 DOM API and ES 2015 Code. Super small, super smart, super powerful. Period! Write frontend apps without the hassle of a complex framework, use the full power of HTML 5, keep a component based style.","title":"@nyaf is \"Not Yet Another Framework\""},{"location":"#elevator-pitch","text":"Since the amazing impact of jQuery in 2006 we have seen an uncountable number of JavaScript frameworks. Some good, some nice, a few excellent. Each time has it's leading frameworks and an audience that loves it. The comes from simple properties. It should save time compared with programming on a basic level. It should give stability and reliability to your apps where things in the browser's internal parts get messy. And it adds another layer of indirection to make things smooth and good looking, nicely maintainable, and well architectured. But over time, frameworks get elder. And they can't change and involve, because they already have a broad audience and hundreds or thousands of projects rely on them. The manufacturer can't break everything to go the next step. The programmers get stuck. And the world of browser programming has evolved dramatically. Meanwhile, we have an amazingly powerful native API in HTML 5. One of the most important innovations in browser development where Web Components. The API is easy to learn, the support is complete for all modern browsers, and the implementation is stable. At the same time the programming language TypeScript come to us along with a powerful toolset. It's time for the next step. Take the leading tools and create an easy to use library, that covers the hard stuff and be invisible where the native API is almost the best. That's @NYAF.","title":"Elevator Pitch"},{"location":"#parts","text":"The library comes in three parts: A Core library that handles Web Components the easy way, provide a router for Single Page Apps, and adds a nice template language A Forms library that handles data binding and decorator based validation A Store library that gives your app a state engine using the common flux architecture style Everything else is simple HTML 5 API, without any restrictions. You can add CSS, other libraries, or your own stuff at almost any position.","title":"Parts"},{"location":"md/intro/","text":"The Idea # We want to use JSX/TSX syntax for quick component dev. We want to have support to make a Single Page App (SPA). We want to use any current HTML 5 API, such as web components, fetch, and all this with ES2015. We want to have a simple template language, that avoids clunky map, reduce, filter stuff within the HTML. We want to use TypeScript from the beginning. We want to get a very small package. We want to use WebPack and other common tools. We want to use standards, no weird CLI, no vendor lock in. We want to use smart decorators for controlling stuff, not code within the component, for separation of concerns style. Approach # It's based on TSX. It does not use React, though. In fact, it's just a feature of the TypeScript compiler. See this excerpt from tsconfig.json : jsx : react , reactNamespace : JSX , A class JSX is the core, it handles the element definitions and extract the template extensions. Quick Start # Summary # Is it worth coding with @nyaf and vanilla JS/TS? For smaller projects and for apps that must load quickly, yes. Actual sizes (0.5.23): Core: 31 KB -- 10 KB zipped (always needed) Forms: 43 KB -- 13 KB zipped (Forms binding, validation, decorators) Store: 34 KB -- 11 KB zipped (Flux like store for state management) Total: 108 KB -- 34 KB zipped all files together for your project However, compared with React or Angular it's a lot simpler. Compared to Vue, Svelte or Polymer it's simpler and even smaller, but the delta is not that thrilling. Tool Support # What tool support? It's Web Components - any editor will do. It's JSX/TSX, so any good editor can handle this. And there are TypeScript decorators, even this is well supported. So, you don't need to tweak your editor. It works, no red squiggles, guaranteed. Restrictions # The package runs, if there are no polyfills, only with ES2015. This limits the usage to any modern browser. It's pretty bold in Electron projects. Credits # Inspired by: Angular (thanks for the idea of using decorators) Polymer (especially lit-element, thanks for showing that Web Components are bold) React (thanks for JSX) Vue (thanks for showing short custom attributes) Svelte (thanks for showing short custom attributes) TypeScript (thanks for making JS cool again) Readings # There is a book in the making covering all aspects of @nyaf : https://leanpub.com/webcomponentsnyaf. Read everything about Web Components, why they are smart and how @nyaf handles them. Further steps # Look out for '@nyaf/forms' (forms validation, data binding, UI control) and '@nyaf/store' (a simple flux store). Simple but powerful!","title":"Introduction"},{"location":"md/intro/#the-idea","text":"We want to use JSX/TSX syntax for quick component dev. We want to have support to make a Single Page App (SPA). We want to use any current HTML 5 API, such as web components, fetch, and all this with ES2015. We want to have a simple template language, that avoids clunky map, reduce, filter stuff within the HTML. We want to use TypeScript from the beginning. We want to get a very small package. We want to use WebPack and other common tools. We want to use standards, no weird CLI, no vendor lock in. We want to use smart decorators for controlling stuff, not code within the component, for separation of concerns style.","title":"The Idea"},{"location":"md/intro/#approach","text":"It's based on TSX. It does not use React, though. In fact, it's just a feature of the TypeScript compiler. See this excerpt from tsconfig.json : jsx : react , reactNamespace : JSX , A class JSX is the core, it handles the element definitions and extract the template extensions.","title":"Approach"},{"location":"md/intro/#quick-start","text":"","title":"Quick Start"},{"location":"md/intro/#summary","text":"Is it worth coding with @nyaf and vanilla JS/TS? For smaller projects and for apps that must load quickly, yes. Actual sizes (0.5.23): Core: 31 KB -- 10 KB zipped (always needed) Forms: 43 KB -- 13 KB zipped (Forms binding, validation, decorators) Store: 34 KB -- 11 KB zipped (Flux like store for state management) Total: 108 KB -- 34 KB zipped all files together for your project However, compared with React or Angular it's a lot simpler. Compared to Vue, Svelte or Polymer it's simpler and even smaller, but the delta is not that thrilling.","title":"Summary"},{"location":"md/intro/#tool-support","text":"What tool support? It's Web Components - any editor will do. It's JSX/TSX, so any good editor can handle this. And there are TypeScript decorators, even this is well supported. So, you don't need to tweak your editor. It works, no red squiggles, guaranteed.","title":"Tool Support"},{"location":"md/intro/#restrictions","text":"The package runs, if there are no polyfills, only with ES2015. This limits the usage to any modern browser. It's pretty bold in Electron projects.","title":"Restrictions"},{"location":"md/intro/#credits","text":"Inspired by: Angular (thanks for the idea of using decorators) Polymer (especially lit-element, thanks for showing that Web Components are bold) React (thanks for JSX) Vue (thanks for showing short custom attributes) Svelte (thanks for showing short custom attributes) TypeScript (thanks for making JS cool again)","title":"Credits"},{"location":"md/intro/#readings","text":"There is a book in the making covering all aspects of @nyaf : https://leanpub.com/webcomponentsnyaf. Read everything about Web Components, why they are smart and how @nyaf handles them.","title":"Readings"},{"location":"md/intro/#further-steps","text":"Look out for '@nyaf/forms' (forms validation, data binding, UI control) and '@nyaf/store' (a simple flux store). Simple but powerful!","title":"Further steps"},{"location":"md/learn/","text":"Learn @nyaf # @nyaf is a JavaScript library for building user interfaces. Learn what @nyaf is all about on our homepage or in the tutorial. Try nyaf # nyaf has been designed from the start for gradual adoption, and you can use as little or as much nyaf as you need. Whether you want to get a taste of nyaf , add some interactivity to a simple HTML page, or start a complex nyaf -powered app, the links in this section will help you get started. Online Playgrounds # If you\u2019re interested in playing around with nyaf , you can use an online code playground. Try a Hello World template on CodePen, CodeSandbox, Glitch, or Stackblitz. If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we\u2019d only recommend using this for simple demos. Add nyaf to a Website # You can add nyaf to an HTML page in one minute. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets. Create a New nyaf App # When starting a nyaf project, a simple HTML page with script tags might still be the best option. It only takes a minute to set up! As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich nyaf ecosystem. Learn how. Learn nyaf # People come to nyaf from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you\u2019ll find this section helpful. If you prefer to learn by doing, start with our practical tutorial. If you prefer to learn concepts step by step, start with our guide to main concepts. Like any unfamiliar technology, nyaf does have a learning curve. With practice and some patience, you will get the hang of it. First Examples # The nyaf homepage contains a few small nyaf examples with a live editor. Even if you don\u2019t know anything about nyaf yet, try changing their code and see how it affects the result. nyaf for Beginners # If you feel that the nyaf documentation goes at a faster pace than you\u2019re comfortable with, check out this overview of nyaf by Tania Rascia. It introduces the most important nyaf concepts in a detailed, beginner-friendly way. Once you\u2019re done, give the documentation another try! nyaf for Designers # If you\u2019re coming from a design background, these resources are a great place to get started. JavaScript Resources # The nyaf documentation assumes some familiarity with programming in the JavaScript language. You don\u2019t have to be an expert, but it\u2019s harder to learn both nyaf and JavaScript at the same time. We recommend going through this JavaScript overview to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning nyaf . Tip: Whenever you get confused by something in JavaScript, MDN and javascript.info are great websites to check. There are also community support forums where you can ask for help. Practical Tutorial # If you prefer to learn by doing, check out our practical tutorial. In this tutorial, we build a tic-tac-toe game in nyaf . You might be tempted to skip it because you\u2019re not into building games \u2014 but give it a chance. The techniques you\u2019ll learn in the tutorial are fundamental to building any nyaf apps, and mastering it will give you a much deeper understanding. Step-by-Step Guide # If you prefer to learn concepts step by step, our guide to main concepts is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won\u2019t miss anything as you go along. Thinking in nyaf # Many nyaf users credit reading Thinking in nyaf as the moment nyaf finally \u201cclicked\u201d for them. It\u2019s probably the oldest nyaf walk-through but it\u2019s still just as relevant. Recommended Courses # Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain a list of commonly recommended resources, some of which are free. Advanced Concepts # Once you\u2019re comfortable with the main concepts and played with nyaf a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used nyaf features like context and refs. API Reference # This documentation section is useful when you want to learn more details about a particular nyaf API. For example, nyaf .Component API reference can provide you with details on how setState() works, and what different lifecycle methods are useful for. Glossary and FAQ # The glossary contains an overview of the most common terms you\u2019ll see in the nyaf documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including making AJAX requests, component state, and file structure.","title":"Learn"},{"location":"md/learn/#learn-nyaf","text":"@nyaf is a JavaScript library for building user interfaces. Learn what @nyaf is all about on our homepage or in the tutorial.","title":"Learn @nyaf"},{"location":"md/learn/#try-nyaf","text":"nyaf has been designed from the start for gradual adoption, and you can use as little or as much nyaf as you need. Whether you want to get a taste of nyaf , add some interactivity to a simple HTML page, or start a complex nyaf -powered app, the links in this section will help you get started.","title":"Try nyaf"},{"location":"md/learn/#online-playgrounds","text":"If you\u2019re interested in playing around with nyaf , you can use an online code playground. Try a Hello World template on CodePen, CodeSandbox, Glitch, or Stackblitz. If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we\u2019d only recommend using this for simple demos.","title":"Online Playgrounds"},{"location":"md/learn/#add-nyaf-to-a-website","text":"You can add nyaf to an HTML page in one minute. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.","title":"Add nyaf to a Website"},{"location":"md/learn/#create-a-new-nyaf-app","text":"When starting a nyaf project, a simple HTML page with script tags might still be the best option. It only takes a minute to set up! As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich nyaf ecosystem. Learn how.","title":"Create a New nyaf App"},{"location":"md/learn/#learn-nyaf_1","text":"People come to nyaf from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you\u2019ll find this section helpful. If you prefer to learn by doing, start with our practical tutorial. If you prefer to learn concepts step by step, start with our guide to main concepts. Like any unfamiliar technology, nyaf does have a learning curve. With practice and some patience, you will get the hang of it.","title":"Learn nyaf"},{"location":"md/learn/#first-examples","text":"The nyaf homepage contains a few small nyaf examples with a live editor. Even if you don\u2019t know anything about nyaf yet, try changing their code and see how it affects the result.","title":"First Examples"},{"location":"md/learn/#nyaf-for-beginners","text":"If you feel that the nyaf documentation goes at a faster pace than you\u2019re comfortable with, check out this overview of nyaf by Tania Rascia. It introduces the most important nyaf concepts in a detailed, beginner-friendly way. Once you\u2019re done, give the documentation another try!","title":"nyaf for Beginners"},{"location":"md/learn/#nyaf-for-designers","text":"If you\u2019re coming from a design background, these resources are a great place to get started.","title":"nyaf for Designers"},{"location":"md/learn/#javascript-resources","text":"The nyaf documentation assumes some familiarity with programming in the JavaScript language. You don\u2019t have to be an expert, but it\u2019s harder to learn both nyaf and JavaScript at the same time. We recommend going through this JavaScript overview to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning nyaf . Tip: Whenever you get confused by something in JavaScript, MDN and javascript.info are great websites to check. There are also community support forums where you can ask for help.","title":"JavaScript Resources"},{"location":"md/learn/#practical-tutorial","text":"If you prefer to learn by doing, check out our practical tutorial. In this tutorial, we build a tic-tac-toe game in nyaf . You might be tempted to skip it because you\u2019re not into building games \u2014 but give it a chance. The techniques you\u2019ll learn in the tutorial are fundamental to building any nyaf apps, and mastering it will give you a much deeper understanding.","title":"Practical Tutorial"},{"location":"md/learn/#step-by-step-guide","text":"If you prefer to learn concepts step by step, our guide to main concepts is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won\u2019t miss anything as you go along.","title":"Step-by-Step Guide"},{"location":"md/learn/#thinking-in-nyaf","text":"Many nyaf users credit reading Thinking in nyaf as the moment nyaf finally \u201cclicked\u201d for them. It\u2019s probably the oldest nyaf walk-through but it\u2019s still just as relevant.","title":"Thinking in nyaf"},{"location":"md/learn/#recommended-courses","text":"Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain a list of commonly recommended resources, some of which are free.","title":"Recommended Courses"},{"location":"md/learn/#advanced-concepts","text":"Once you\u2019re comfortable with the main concepts and played with nyaf a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used nyaf features like context and refs.","title":"Advanced Concepts"},{"location":"md/learn/#api-reference","text":"This documentation section is useful when you want to learn more details about a particular nyaf API. For example, nyaf .Component API reference can provide you with details on how setState() works, and what different lifecycle methods are useful for.","title":"API Reference"},{"location":"md/learn/#glossary-and-faq","text":"The glossary contains an overview of the most common terms you\u2019ll see in the nyaf documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including making AJAX requests, component state, and file structure.","title":"Glossary and FAQ"},{"location":"md/setup/","text":"Getting Started # Typically, you start like this: $ npm i @nyaf/lib Just start from scratch by a simple setup, which includes: A package.json and a tsconfig.json A src folder, containing at least: index.html main.ts component.ts That's it, let the TypeScript compiler create the output and copy static files using cp .","title":"Setup"},{"location":"md/setup/#getting-started","text":"Typically, you start like this: $ npm i @nyaf/lib Just start from scratch by a simple setup, which includes: A package.json and a tsconfig.json A src folder, containing at least: index.html main.ts component.ts That's it, let the TypeScript compiler create the output and copy static files using cp .","title":"Getting Started"},{"location":"md/docs/comparision/angular/","text":"@nyaf and Angular # Angular is a full-fledged framework that has an answer for everything. It comes with huge amount of code. The main reason to use Angular is to have a very powerful template language. It gives developers the feel they must not learn HTML 5 APIs and can still do anything by just learning Angular. That's true, but what the guys at Google not say is that the learning curve is extremely steep and it's a long way until you master Angular. Would you learn HTML 5 instead... but that's to easy, isn't it? Taking the Best # Angular comes with full support of TypeScript (actually, it's written in TypeScript) and all the new handy features, such as Decorators. That's the same as in @nyaf. Let's compare it a bit here. Components # A component in Angular is decorated with @Component({}) . It needs several settings, though. A component in @nyaf is quite the same, using @CustomElement('name') . Despite the name no additional settings required. Angular comes with a template language you have to learn. ul li *ngFor= let item of items {{ item.text }} /li /ul The part to learn is the very proprietary * ngFor instruction. Some JavaScript is possible here, but very restrictive. @nyaf comes with TSX, which is TypeScript with embedded HTML elements. Not so much to learn here. const lis = this.items.map(item = li { item.text }) /li ); ul { lis } /ul There is nothing special, it's an array with a map function call. HTML remains \"as is\". You could even make it short like this: ul { this.items.map(item = li { item.text }) /li ) } /ul However, in bigger components this could reduce the readability. But anyway, three lines of code against three lines of code. Any sort of JavaScript is allowed in here, as long as it fits into a function call. Binding # Angular has great data binding. @nyaf has this, too, but on request. Let's return to the last example. In Angular the list items will re-render if the collection items changes. That's smart and easy to use. It comes with a big penalty: Huge template compiler that inserts a lot boilerplate code for you. div class= alert alert-danger {{ message }} /div Supporting steps required (component and binding property): @Component({ selector: 'app-demo', templateUrl: 'code-from-last-example.html' }) { public message: string; } That's smart, because it's easy to use. In @nyaf you load the module @nyaf/forms and use explicit binding: div class= alert alert-danger n-bind={to Messages (m = m.message), 'innerText'} /div Supporting steps required (component and viewmodel): // create a viewmodel export class Messages { message: string; } @ViewModel Messages (Messages) @CustomElement('app-demo') export class AppDemoComponent { // component goes here } That's great because it has several advantages: Binding only if required The viewmodel approach is a better way to implement a \"separation of concerns\" pattern Full editor / IntelliSense support due to using TypeScript in the TSX syntax ({} braces) - without additional tooling or plug-ins Customizable binders to exactly what you need No memory footprint, there is no boilerplate code or generated stuff (it's a JavaScript native Proxy behind the scene)","title":"...Angular"},{"location":"md/docs/comparision/angular/#nyaf-and-angular","text":"Angular is a full-fledged framework that has an answer for everything. It comes with huge amount of code. The main reason to use Angular is to have a very powerful template language. It gives developers the feel they must not learn HTML 5 APIs and can still do anything by just learning Angular. That's true, but what the guys at Google not say is that the learning curve is extremely steep and it's a long way until you master Angular. Would you learn HTML 5 instead... but that's to easy, isn't it?","title":"@nyaf and Angular"},{"location":"md/docs/comparision/angular/#taking-the-best","text":"Angular comes with full support of TypeScript (actually, it's written in TypeScript) and all the new handy features, such as Decorators. That's the same as in @nyaf. Let's compare it a bit here.","title":"Taking the Best"},{"location":"md/docs/comparision/angular/#components","text":"A component in Angular is decorated with @Component({}) . It needs several settings, though. A component in @nyaf is quite the same, using @CustomElement('name') . Despite the name no additional settings required. Angular comes with a template language you have to learn. ul li *ngFor= let item of items {{ item.text }} /li /ul The part to learn is the very proprietary * ngFor instruction. Some JavaScript is possible here, but very restrictive. @nyaf comes with TSX, which is TypeScript with embedded HTML elements. Not so much to learn here. const lis = this.items.map(item = li { item.text }) /li ); ul { lis } /ul There is nothing special, it's an array with a map function call. HTML remains \"as is\". You could even make it short like this: ul { this.items.map(item = li { item.text }) /li ) } /ul However, in bigger components this could reduce the readability. But anyway, three lines of code against three lines of code. Any sort of JavaScript is allowed in here, as long as it fits into a function call.","title":"Components"},{"location":"md/docs/comparision/angular/#binding","text":"Angular has great data binding. @nyaf has this, too, but on request. Let's return to the last example. In Angular the list items will re-render if the collection items changes. That's smart and easy to use. It comes with a big penalty: Huge template compiler that inserts a lot boilerplate code for you. div class= alert alert-danger {{ message }} /div Supporting steps required (component and binding property): @Component({ selector: 'app-demo', templateUrl: 'code-from-last-example.html' }) { public message: string; } That's smart, because it's easy to use. In @nyaf you load the module @nyaf/forms and use explicit binding: div class= alert alert-danger n-bind={to Messages (m = m.message), 'innerText'} /div Supporting steps required (component and viewmodel): // create a viewmodel export class Messages { message: string; } @ViewModel Messages (Messages) @CustomElement('app-demo') export class AppDemoComponent { // component goes here } That's great because it has several advantages: Binding only if required The viewmodel approach is a better way to implement a \"separation of concerns\" pattern Full editor / IntelliSense support due to using TypeScript in the TSX syntax ({} braces) - without additional tooling or plug-ins Customizable binders to exactly what you need No memory footprint, there is no boilerplate code or generated stuff (it's a JavaScript native Proxy behind the scene)","title":"Binding"},{"location":"md/docs/comparision/polymer/","text":"Polymer Lit-Element # That's really close, but still - Polymer is a bit to restrictive concerning TypeScript. These guys over their like Babel to much. Components # See the entry example in Polymer form their docs: import { LitElement, html, property, customElement } from 'lit-element'; @customElement('simple-greeting') export class SimpleGreeting extends LitElement { @property() name = 'World'; render() { return html` p Hello, ${this.name}! /p `; } } // Usage somewhere else in HTML simple-greeting name= Everyone /simple-greeting See the same in @nyaf: import { BaseComponent, CustomElement, Properties } from '@nyaf/lib'; @CustomElement('simple-greeting') @Properties({ name = 'World' }); export class SimpleGreeting extends BaseComponent { name: string } { async render() { return await p Hello, {this.data.name}! /p ; } } // Usage somewhere else in HTML simple-greeting name= Everyone /simple-greeting As in React, Polymer's lit-element doesn't has any template features.","title":"...Polymer"},{"location":"md/docs/comparision/polymer/#polymer-lit-element","text":"That's really close, but still - Polymer is a bit to restrictive concerning TypeScript. These guys over their like Babel to much.","title":"Polymer Lit-Element"},{"location":"md/docs/comparision/polymer/#components","text":"See the entry example in Polymer form their docs: import { LitElement, html, property, customElement } from 'lit-element'; @customElement('simple-greeting') export class SimpleGreeting extends LitElement { @property() name = 'World'; render() { return html` p Hello, ${this.name}! /p `; } } // Usage somewhere else in HTML simple-greeting name= Everyone /simple-greeting See the same in @nyaf: import { BaseComponent, CustomElement, Properties } from '@nyaf/lib'; @CustomElement('simple-greeting') @Properties({ name = 'World' }); export class SimpleGreeting extends BaseComponent { name: string } { async render() { return await p Hello, {this.data.name}! /p ; } } // Usage somewhere else in HTML simple-greeting name= Everyone /simple-greeting As in React, Polymer's lit-element doesn't has any template features.","title":"Components"},{"location":"md/docs/comparision/preact/","text":"","title":"...Preact"},{"location":"md/docs/comparision/react/","text":"nyaf and React # Due to the nature of using TSX/JSX for templates it seems that React is quite close. But that's not entirely true. @nyaf has a lot to offer. Components # React is based on JavaScript and not native in TypeScript. That seems just a small issue, as TypeScript compiles down to JavaScript anyway, but in reality it's a big deal. Because of the non-native development style the TypeScript form is not very elegant. And the real advantage of TypeScript, such as advanced types like decorators and interfaces, are not or rarely used. Let's compare it. React # This is a simple component in React. The name always follows the class name, Welcome in this example. class Welcome extends BaseComponent {} { render() { return h1 Hello, {this.props.name} /h1 ; } } @nyaf # This is a simple component on @nyaf. The name is defined separately, and so is the property definition. Apart from this, it's the same. @CustomElement('app-welcome') @Properties({ name: '' }) class WelcomeComponent extends BaseComponent { name: string } { async render() { return await h1 Hello, {this.data.name} /h1 ; } } The element style is more natural, because the browser engine processes the Web Components, not custom code. Because of the generic the editor will recognize and resolve the this.data property, too. Also, the render code allows async calls to pull data from a data source or do other non-blocking stuff. State # React documentation says: Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable. In @nyaf it's a similar mechanism, but simpler. There is no distinguish between props and state, you define properties and held the state in it. There is no need to use the properties, then. That's why it's called data and purposefully setData() . However, you can set the state directly on the object and don't need to follow restrictions. It's a Proxy under the hat that handles the changes. If something isn't allows the property would be readonly and the editor shows this, no need to read documentation and remember it all the time. Events # In React a so-called synthetic event looks like this: button onClick={activateLasers} Activate Lasers /button In @nyaf it's not that different: button n-on-click={this.activateLasers} Activate Lasers /button The this quantifier is necessary. The main reason is that the code transforms directly into JavaScript and there is nothing \"synthetic\" here, the template engine connects the method as a dynamic handler directly to the event. However, you can use custom events that transport additional data. But still, it's the browsers event engine that handles these event natively. Conditions # See this example from the React documentation: function UserGreeting(props) { return h1 Welcome back! /h1 ; } function GuestGreeting(props) { return h1 Please sign up. /h1 ; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return UserGreeting / ; } return GuestGreeting / ; } In @nyaf this would look a bit different. @CustomElement('user-greeting') export class UserGreeting extends BaseComponent void { constructor() { super(); } async render() { return await h1 Welcome back! /h1 ; } } @CustomElement('guest-greeting') export class GuestGreeting() extends BaseComponent void { constructor() { super(); } async render() { return await h1 Please sign up. /h1 ; } } @CustomElement('app-greeting') export class Greeting() extends BaseComponent { isLoggedIn: boolean} { constructor() { super(); } async render() { const isLoggedIn = this.data.isLoggedIn; return await ( user-greeting n-if={isLoggedIn} / guest-greeting n-if={!isLoggedIn} / ); } It's a little more verbose, but it's easier to read due to additional template functions, here n-if . Lists # As far as it's just JSX the handling is the same in React and @nyaf. The key feature for rendering of list items according to element changes does not exist in @nyaf. The render engine will always render the whole list, if something changes. That's not that smart, but it reduces the template code drastically.","title":"...React"},{"location":"md/docs/comparision/react/#nyaf-and-react","text":"Due to the nature of using TSX/JSX for templates it seems that React is quite close. But that's not entirely true. @nyaf has a lot to offer.","title":"nyaf and React"},{"location":"md/docs/comparision/react/#components","text":"React is based on JavaScript and not native in TypeScript. That seems just a small issue, as TypeScript compiles down to JavaScript anyway, but in reality it's a big deal. Because of the non-native development style the TypeScript form is not very elegant. And the real advantage of TypeScript, such as advanced types like decorators and interfaces, are not or rarely used. Let's compare it.","title":"Components"},{"location":"md/docs/comparision/react/#react","text":"This is a simple component in React. The name always follows the class name, Welcome in this example. class Welcome extends BaseComponent {} { render() { return h1 Hello, {this.props.name} /h1 ; } }","title":"React"},{"location":"md/docs/comparision/react/#nyaf","text":"This is a simple component on @nyaf. The name is defined separately, and so is the property definition. Apart from this, it's the same. @CustomElement('app-welcome') @Properties({ name: '' }) class WelcomeComponent extends BaseComponent { name: string } { async render() { return await h1 Hello, {this.data.name} /h1 ; } } The element style is more natural, because the browser engine processes the Web Components, not custom code. Because of the generic the editor will recognize and resolve the this.data property, too. Also, the render code allows async calls to pull data from a data source or do other non-blocking stuff.","title":"@nyaf"},{"location":"md/docs/comparision/react/#state","text":"React documentation says: Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable. In @nyaf it's a similar mechanism, but simpler. There is no distinguish between props and state, you define properties and held the state in it. There is no need to use the properties, then. That's why it's called data and purposefully setData() . However, you can set the state directly on the object and don't need to follow restrictions. It's a Proxy under the hat that handles the changes. If something isn't allows the property would be readonly and the editor shows this, no need to read documentation and remember it all the time.","title":"State"},{"location":"md/docs/comparision/react/#events","text":"In React a so-called synthetic event looks like this: button onClick={activateLasers} Activate Lasers /button In @nyaf it's not that different: button n-on-click={this.activateLasers} Activate Lasers /button The this quantifier is necessary. The main reason is that the code transforms directly into JavaScript and there is nothing \"synthetic\" here, the template engine connects the method as a dynamic handler directly to the event. However, you can use custom events that transport additional data. But still, it's the browsers event engine that handles these event natively.","title":"Events"},{"location":"md/docs/comparision/react/#conditions","text":"See this example from the React documentation: function UserGreeting(props) { return h1 Welcome back! /h1 ; } function GuestGreeting(props) { return h1 Please sign up. /h1 ; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return UserGreeting / ; } return GuestGreeting / ; } In @nyaf this would look a bit different. @CustomElement('user-greeting') export class UserGreeting extends BaseComponent void { constructor() { super(); } async render() { return await h1 Welcome back! /h1 ; } } @CustomElement('guest-greeting') export class GuestGreeting() extends BaseComponent void { constructor() { super(); } async render() { return await h1 Please sign up. /h1 ; } } @CustomElement('app-greeting') export class Greeting() extends BaseComponent { isLoggedIn: boolean} { constructor() { super(); } async render() { const isLoggedIn = this.data.isLoggedIn; return await ( user-greeting n-if={isLoggedIn} / guest-greeting n-if={!isLoggedIn} / ); } It's a little more verbose, but it's easier to read due to additional template functions, here n-if .","title":"Conditions"},{"location":"md/docs/comparision/react/#lists","text":"As far as it's just JSX the handling is the same in React and @nyaf. The key feature for rendering of list items according to element changes does not exist in @nyaf. The render engine will always render the whole list, if something changes. That's not that smart, but it reduces the template code drastically.","title":"Lists"},{"location":"md/docs/comparision/stencil/","text":"","title":"...Stencil"},{"location":"md/docs/comparision/svelte/","text":"","title":"...Svelte"},{"location":"md/docs/comparision/vue/","text":"","title":"...Vue"},{"location":"md/docs/forms/custombinders/","text":"Custom Binders # A custom binder handles the binding procedure when binding a viewmodel property to an element attribute. It consists of three parts: The binding setup ( bind ) The binder into the element (a property change leads to an attribute change) The listener (a attribute change event leads to a updated model property) Step 2 and 3 are both optional, leading to a uni-directional binding in one or another direction. export class VisibilityBinder T extends ConfirmSuccessErrorComponent implements IBindingHandler { bind(binding: Binding): void { (binding.el as T).addEventListener('done', () = { this.listener(binding); }) this.react(binding); } react(binding: Binding): void { (binding.el as T).visibility = !!binding.value; } listener(binding: Binding): void { const value = (binding.el as T).visibility; binding.value = value; } } How simple a binder can be is shown next with the already embedded uni-directional default binder: export class DefaultBindingHandler implements IBindingHandler { bind(binding: Binding): void { } react(binding: Binding, property: string): void { binding.el[property] = binding.value; } } The only difference here is that the ModelBinder class intercepts the access and delivers the name of the attribute as a second parameter. This is a special behavior and the default handler can handle this.","title":"Custom Binders"},{"location":"md/docs/forms/custombinders/#custom-binders","text":"A custom binder handles the binding procedure when binding a viewmodel property to an element attribute. It consists of three parts: The binding setup ( bind ) The binder into the element (a property change leads to an attribute change) The listener (a attribute change event leads to a updated model property) Step 2 and 3 are both optional, leading to a uni-directional binding in one or another direction. export class VisibilityBinder T extends ConfirmSuccessErrorComponent implements IBindingHandler { bind(binding: Binding): void { (binding.el as T).addEventListener('done', () = { this.listener(binding); }) this.react(binding); } react(binding: Binding): void { (binding.el as T).visibility = !!binding.value; } listener(binding: Binding): void { const value = (binding.el as T).visibility; binding.value = value; } } How simple a binder can be is shown next with the already embedded uni-directional default binder: export class DefaultBindingHandler implements IBindingHandler { bind(binding: Binding): void { } react(binding: Binding, property: string): void { binding.el[property] = binding.value; } } The only difference here is that the ModelBinder class intercepts the access and delivers the name of the attribute as a second parameter. This is a special behavior and the default handler can handle this.","title":"Custom Binders"},{"location":"md/docs/forms/nbind/","text":"Template Language Enhancements # @nyaf has a simple template language. For forms it's just one more command for any input element, n-bind : model: ModelBinder UserViewModel ; // instance created by decorator async render() { const model: UserViewModel = new UserViewModel(); // or where ever the model comes from return await ( form input n-bind= value: Name / /form / ); } Now the field knows everything about how to render and how to validate. The first item (\"value\") is the HTML element's property you bind to. The second is the model's property name (\"Name\"). Once you retrieve the DOM object, you get access to validation: const username = this.querySelector('[name= userName ]'); if (username.valid){ // call server } if (username.touched){ // show help } For a good UI you need a label usually: label n-bind= innerText: userName / Forms # The model is provided by a decorator @ViewModel(ModelType) export class component extends BaseComponent any implements IModel ModelType { async render() { return await ( form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un / br / label n-bind= innerText: city for= city / input n-bind= value: city id = city / /form ) } } Forms bind data. It's bi-directional or uni-directional depending on the chosen handler. Validation # The error message is just regular output (class example from Bootstrap, not needed by @nyaf forms): form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un div class= text text-danger n-show={this.model.state.userName.valid this.model.state.userName.touched} innerHTML={this.model.state.userName.errors} /div /form Validators can provide the error text, too. This is driven by decorators. The decorators fall back to a simple plain english error message in case you don't provide anything. You can, however, provide any kind of message in the decorator. In case you need i18n messages, just add the @Translate decorator as a parameter decorator to the message parameter. Distinguish between different validators like this: form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un div class= text text-danger n-show={this.model.state.userName.valid this.model.state.userName.touched} innerHTML={this.model.state.userName.errors.required.error} /div /form Using n-show is mandatory, it's able to react to state changes. n-if is static and will not change visibility after first render process. Objects are always set (not undefined), so you don't must test first. The property names are same as the decorators, but in lower case: @StringLength : stringlength @MaxLength : maximum @MinLength : minimum @Pattern : pattern @Range : range @Required : required @EMail : email @Compare : compare Smart Binders # There is an alternative syntax that provides full type support: label n-bind={to ContactModel (c = c.email, 'innerText', Display)} /label Use the function to Type from @nyaf/forms . The parameters are as follows: An expression to select a property type safe The property of the element. Any property available in HTMLElement is allowed (and it's restricted to these). The (optional) type of decorator that's used to pull data from. If it's omitted, the actual data appear. Obviously you could think about writing this: input n-bind={to ContactModel (c = c.email, 'value')} / This is rejected by the compiler, because the property value doesn't exists in HTMLElement . To provide another type, just use a second generic type parameter: input n-bind={to ContactModel, HTMLInputElement (c = c.email, 'value')} / Here you tell the compiler, that it's safe to use HTMLInputElement and so the editor allows value as the second parameter. An even smarter way is to use the lambda here, too: input n-bind={to ContactModel, HTMLInputElement (c = c.email, c = c.value)} / But, both ways are type safe, even the string is following a constrain. The string is usually shorter, the lambda might use an earlier suggestion from Intellisense. Multi Attribute Binding # The n-bind attribute is exclusive, so you can bind only one attribute. That's fine for most cases, but sometimes you'll need multiple bindings. In Angular this is easy through the binding syntax around any element ( input [type]=\"source\" [value]=\"model\" ). However, this would require a template compiler and additional editor support. To overcome a limitation here, a bind function available: In this example two properties are bound: input value={bind T (c = c.email)} type={bind T (c = c.toggleType)} n-bind / The n-bind is still required to efficiently trigger the binder logic. It's now empty, though (default value is true internally). The binding handler is not provided, so it falls back to a DefaultBindingHandler , that binds uni-directional to the assigned attribute. That has two limitations. First, it's always uni-directional. Second, it can bind only to attributes of HTMLElement . Object properties, such as textContent or innerText cannot be reached that way. That's indeed the same with Angular, where you need to encapsulate elements in custom components to reach hidden properties, but in @nyaf there is a much smarter way. Imagine you'll bind to whatever, just assign another binding handler. input value={bind T (c = c.email, ValueBindingHandler)} n-bind / The binding handler may write into whatever property you like, even those not available as attributes. See (Custom Binders)[custombinders.md] for more details. Even More Smartness # You may also define your component as a generic: // ContactModel defined elsewhere export class ContactComponent T extends ContactModel extends BaseComponent any implements IModel ContactModel { And in that case use a shorter from to express the binding: label n-bind={to T (c = c.email, c = c.innerText)} / That's cool, isn't it? Now we have a fully type save binding definition in the middle of the TSX part without any additions to regular HTML. Any in case you have special properties beyond HTMLElement , than just provide the proper type: input n-bind={to T, HTMLInputElement (c = c.email, c = c.value)} / This gives full type support in any editor for all types, even custom Web Components will work here. This technique avoids parsing the template, and the missing parser makes the package so small. The function simply returns a magic string that the model binder class recognizes at runtime. The function call with a generic helps the editor to understand the types and avoids mistakes.","title":"Data Binding"},{"location":"md/docs/forms/nbind/#template-language-enhancements","text":"@nyaf has a simple template language. For forms it's just one more command for any input element, n-bind : model: ModelBinder UserViewModel ; // instance created by decorator async render() { const model: UserViewModel = new UserViewModel(); // or where ever the model comes from return await ( form input n-bind= value: Name / /form / ); } Now the field knows everything about how to render and how to validate. The first item (\"value\") is the HTML element's property you bind to. The second is the model's property name (\"Name\"). Once you retrieve the DOM object, you get access to validation: const username = this.querySelector('[name= userName ]'); if (username.valid){ // call server } if (username.touched){ // show help } For a good UI you need a label usually: label n-bind= innerText: userName /","title":"Template Language Enhancements"},{"location":"md/docs/forms/nbind/#forms","text":"The model is provided by a decorator @ViewModel(ModelType) export class component extends BaseComponent any implements IModel ModelType { async render() { return await ( form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un / br / label n-bind= innerText: city for= city / input n-bind= value: city id = city / /form ) } } Forms bind data. It's bi-directional or uni-directional depending on the chosen handler.","title":"Forms"},{"location":"md/docs/forms/nbind/#validation","text":"The error message is just regular output (class example from Bootstrap, not needed by @nyaf forms): form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un div class= text text-danger n-show={this.model.state.userName.valid this.model.state.userName.touched} innerHTML={this.model.state.userName.errors} /div /form Validators can provide the error text, too. This is driven by decorators. The decorators fall back to a simple plain english error message in case you don't provide anything. You can, however, provide any kind of message in the decorator. In case you need i18n messages, just add the @Translate decorator as a parameter decorator to the message parameter. Distinguish between different validators like this: form label n-bind= innerText: userName for= un / input n-bind= value: userName id= un div class= text text-danger n-show={this.model.state.userName.valid this.model.state.userName.touched} innerHTML={this.model.state.userName.errors.required.error} /div /form Using n-show is mandatory, it's able to react to state changes. n-if is static and will not change visibility after first render process. Objects are always set (not undefined), so you don't must test first. The property names are same as the decorators, but in lower case: @StringLength : stringlength @MaxLength : maximum @MinLength : minimum @Pattern : pattern @Range : range @Required : required @EMail : email @Compare : compare","title":"Validation"},{"location":"md/docs/forms/nbind/#smart-binders","text":"There is an alternative syntax that provides full type support: label n-bind={to ContactModel (c = c.email, 'innerText', Display)} /label Use the function to Type from @nyaf/forms . The parameters are as follows: An expression to select a property type safe The property of the element. Any property available in HTMLElement is allowed (and it's restricted to these). The (optional) type of decorator that's used to pull data from. If it's omitted, the actual data appear. Obviously you could think about writing this: input n-bind={to ContactModel (c = c.email, 'value')} / This is rejected by the compiler, because the property value doesn't exists in HTMLElement . To provide another type, just use a second generic type parameter: input n-bind={to ContactModel, HTMLInputElement (c = c.email, 'value')} / Here you tell the compiler, that it's safe to use HTMLInputElement and so the editor allows value as the second parameter. An even smarter way is to use the lambda here, too: input n-bind={to ContactModel, HTMLInputElement (c = c.email, c = c.value)} / But, both ways are type safe, even the string is following a constrain. The string is usually shorter, the lambda might use an earlier suggestion from Intellisense.","title":"Smart Binders"},{"location":"md/docs/forms/nbind/#multi-attribute-binding","text":"The n-bind attribute is exclusive, so you can bind only one attribute. That's fine for most cases, but sometimes you'll need multiple bindings. In Angular this is easy through the binding syntax around any element ( input [type]=\"source\" [value]=\"model\" ). However, this would require a template compiler and additional editor support. To overcome a limitation here, a bind function available: In this example two properties are bound: input value={bind T (c = c.email)} type={bind T (c = c.toggleType)} n-bind / The n-bind is still required to efficiently trigger the binder logic. It's now empty, though (default value is true internally). The binding handler is not provided, so it falls back to a DefaultBindingHandler , that binds uni-directional to the assigned attribute. That has two limitations. First, it's always uni-directional. Second, it can bind only to attributes of HTMLElement . Object properties, such as textContent or innerText cannot be reached that way. That's indeed the same with Angular, where you need to encapsulate elements in custom components to reach hidden properties, but in @nyaf there is a much smarter way. Imagine you'll bind to whatever, just assign another binding handler. input value={bind T (c = c.email, ValueBindingHandler)} n-bind / The binding handler may write into whatever property you like, even those not available as attributes. See (Custom Binders)[custombinders.md] for more details.","title":"Multi Attribute Binding"},{"location":"md/docs/forms/nbind/#even-more-smartness","text":"You may also define your component as a generic: // ContactModel defined elsewhere export class ContactComponent T extends ContactModel extends BaseComponent any implements IModel ContactModel { And in that case use a shorter from to express the binding: label n-bind={to T (c = c.email, c = c.innerText)} / That's cool, isn't it? Now we have a fully type save binding definition in the middle of the TSX part without any additions to regular HTML. Any in case you have special properties beyond HTMLElement , than just provide the proper type: input n-bind={to T, HTMLInputElement (c = c.email, c = c.value)} / This gives full type support in any editor for all types, even custom Web Components will work here. This technique avoids parsing the template, and the missing parser makes the package so small. The function simply returns a magic string that the model binder class recognizes at runtime. The function call with a generic helps the editor to understand the types and avoids mistakes.","title":"Even More Smartness"},{"location":"md/docs/forms/overview/","text":"Forms Extensions # Forms provides these basic features: UI control decorators (example: @Hidden() to suppress a property in a dynamic table). Validation decorators (example: @StringLength(50) or @Required() to manage form validation). Data Binding using a model declaration decorator called @ViewModel and a bind property named n-bind . Form validation is a key part of any project. However, CSS frameworks require different strategies to handle errors and so on. Hence, the @nyaf/forms library provides a simple way (just like a skeleton) to give you the direction, but the actual validation implementation logic is up to you to build. Same for the UI decorators. It's a convenient way to add hidden properties to viewmodels. There is no logic to read these values, this is up to you to implement this. However, the decorators makes your life a lot easier. The binding logic is almost complete and once you have a decorated model it's syncing the UI automagically. How it Works # For full support you need view models, the registration on top of the component, and access to the model binder. View models are plain TypeScript classed with public properties enhanced by decorators The registration is the decorator @ViewModel() on top of the component's class The modelbinder comes through implementing the interface IModel ViewModelType View Models in Components # For a nice view decorators applied to class properties control the appearance. Use the decorator @ViewModel T (T) to define the model. The generic is the type, the constructor parameter defines the default values (it's mandatory ). To get access to the model binder, just implement the interface IModel as show below: export class Model { @Hidden() id: number = 0; @Required() name: string = ''; } @CustomElement('app-main') @ViewModel Model (Model) export class MainComponent extends BaseComponent {} implements IModel Model { // ... omitted for brevity } Within the component, the model binder is present through the property this.model . That's the only property. this.model. ...// do some stuff here You can assign an actual object to the model binder. That can happen at any time, in the constructor, in load life cycle, or anytime later on user action. Use this code: this.model.scope = new Model(); However, the @ViewModel decorator is doing exactly this for you, so in case of a new black instance there is no need to call the scope property. It's no necessary to keep a reference to the instance, the model binder is doing this internally for you. The derived class is a Proxy . If you now bind the properties using n-bind as described before, the model is in sync with the user interface. If you want to programmatically access the current state, just retrieve the model: let userName: string = this.model.scope.userName; If you wish to access the Proxy at any time in code or not using the binding in templates, this would be sufficient: private modelProxy: Model; constructor() { super(); this.model.scope = new Model(); this.modelProxy = this.model.scope; } The setter scope takes an instance, wraps this into a Proxy , assigns the binders, and the getter returns the Proxy . Changes to the model will now reflect in bound HTML elements immediately. Validation # The validation state is available through state : this.model.state = { isValid: boolean, isPresent: boolean, errors: { [key: string]: string }, model: Model } It's supervised. After render this.model.state helds the state of the model.","title":"Overview"},{"location":"md/docs/forms/overview/#forms-extensions","text":"Forms provides these basic features: UI control decorators (example: @Hidden() to suppress a property in a dynamic table). Validation decorators (example: @StringLength(50) or @Required() to manage form validation). Data Binding using a model declaration decorator called @ViewModel and a bind property named n-bind . Form validation is a key part of any project. However, CSS frameworks require different strategies to handle errors and so on. Hence, the @nyaf/forms library provides a simple way (just like a skeleton) to give you the direction, but the actual validation implementation logic is up to you to build. Same for the UI decorators. It's a convenient way to add hidden properties to viewmodels. There is no logic to read these values, this is up to you to implement this. However, the decorators makes your life a lot easier. The binding logic is almost complete and once you have a decorated model it's syncing the UI automagically.","title":"Forms Extensions"},{"location":"md/docs/forms/overview/#how-it-works","text":"For full support you need view models, the registration on top of the component, and access to the model binder. View models are plain TypeScript classed with public properties enhanced by decorators The registration is the decorator @ViewModel() on top of the component's class The modelbinder comes through implementing the interface IModel ViewModelType","title":"How it Works"},{"location":"md/docs/forms/overview/#view-models-in-components","text":"For a nice view decorators applied to class properties control the appearance. Use the decorator @ViewModel T (T) to define the model. The generic is the type, the constructor parameter defines the default values (it's mandatory ). To get access to the model binder, just implement the interface IModel as show below: export class Model { @Hidden() id: number = 0; @Required() name: string = ''; } @CustomElement('app-main') @ViewModel Model (Model) export class MainComponent extends BaseComponent {} implements IModel Model { // ... omitted for brevity } Within the component, the model binder is present through the property this.model . That's the only property. this.model. ...// do some stuff here You can assign an actual object to the model binder. That can happen at any time, in the constructor, in load life cycle, or anytime later on user action. Use this code: this.model.scope = new Model(); However, the @ViewModel decorator is doing exactly this for you, so in case of a new black instance there is no need to call the scope property. It's no necessary to keep a reference to the instance, the model binder is doing this internally for you. The derived class is a Proxy . If you now bind the properties using n-bind as described before, the model is in sync with the user interface. If you want to programmatically access the current state, just retrieve the model: let userName: string = this.model.scope.userName; If you wish to access the Proxy at any time in code or not using the binding in templates, this would be sufficient: private modelProxy: Model; constructor() { super(); this.model.scope = new Model(); this.modelProxy = this.model.scope; } The setter scope takes an instance, wraps this into a Proxy , assigns the binders, and the getter returns the Proxy . Changes to the model will now reflect in bound HTML elements immediately.","title":"View Models in Components"},{"location":"md/docs/forms/overview/#validation","text":"The validation state is available through state : this.model.state = { isValid: boolean, isPresent: boolean, errors: { [key: string]: string }, model: Model } It's supervised. After render this.model.state helds the state of the model.","title":"Validation"},{"location":"md/docs/forms/setup/","text":"Installation # Install the package: npm i @nyaf/forms -S Dependencies # Depends on @nyaf/lib .","title":"Setup"},{"location":"md/docs/forms/setup/#installation","text":"Install the package: npm i @nyaf/forms -S","title":"Installation"},{"location":"md/docs/forms/setup/#dependencies","text":"Depends on @nyaf/lib .","title":"Dependencies"},{"location":"md/docs/forms/vm/","text":"View Models # First, you need view models. Then, you decorate the properties with validation and hint decorators. A view model could look like this: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', 'The user\\'s phone') @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } The last (optional) parameter of the validation decorators is a custom error message. Validation Decorators # Validation properties can be used together with the binding. After a binding action took place, usually after a change by the user, the state of the bound model updates and can be retrieved immediately. Elements bound to validation signals can use the state to show/hide elements or control sending data in code. The property names are the same as the respective decorators, just all lower case. Decorator Usage @StringLength Set the strings minimum (optional) and maximum length. It's a summary of @MinLength and @MaxLength . @MaxLength The maximum length of a text input. @MinLength The minimum length of a text input. @Pattern A regular expression that is used to test the text or number input. @Range A range (from-to) for either numerical values or dates. @Required Makes the field mandatory. @EMail Checks input against a (very good) regular expression to test for valid e-mail pattern. @Compare Compares with another field, usually for password comparison. UI Decorators (property level) # UI decorators control the appearance of elements. Not all have an immediate effect, but it's very helpful while creating components to have meta data available. Decorator Usage @Display Determine the label's name and a tooltip ( optionally). @DisplayGroup Groups components in fieldset elements. Can be ordered inside the form. @Hidden Makes an hidden field. @Sortable Makes a column sortable in table views. @Filterable Adds a filter in table views. @Placeholder A watermark that appears in empty form fields @ReadOnly Forces a particular render type. Usually you get fields a shown in the table below. With a hint you can force other types. @TemplateHint What kind of field (text, number, date, ...) and additional styles or classes. @Translate For i18n of components","title":"View Models"},{"location":"md/docs/forms/vm/#view-models","text":"First, you need view models. Then, you decorate the properties with validation and hint decorators. A view model could look like this: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', 'The user\\'s phone') @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } The last (optional) parameter of the validation decorators is a custom error message.","title":"View Models"},{"location":"md/docs/forms/vm/#validation-decorators","text":"Validation properties can be used together with the binding. After a binding action took place, usually after a change by the user, the state of the bound model updates and can be retrieved immediately. Elements bound to validation signals can use the state to show/hide elements or control sending data in code. The property names are the same as the respective decorators, just all lower case. Decorator Usage @StringLength Set the strings minimum (optional) and maximum length. It's a summary of @MinLength and @MaxLength . @MaxLength The maximum length of a text input. @MinLength The minimum length of a text input. @Pattern A regular expression that is used to test the text or number input. @Range A range (from-to) for either numerical values or dates. @Required Makes the field mandatory. @EMail Checks input against a (very good) regular expression to test for valid e-mail pattern. @Compare Compares with another field, usually for password comparison.","title":"Validation Decorators"},{"location":"md/docs/forms/vm/#ui-decorators-property-level","text":"UI decorators control the appearance of elements. Not all have an immediate effect, but it's very helpful while creating components to have meta data available. Decorator Usage @Display Determine the label's name and a tooltip ( optionally). @DisplayGroup Groups components in fieldset elements. Can be ordered inside the form. @Hidden Makes an hidden field. @Sortable Makes a column sortable in table views. @Filterable Adds a filter in table views. @Placeholder A watermark that appears in empty form fields @ReadOnly Forces a particular render type. Usually you get fields a shown in the table below. With a hint you can force other types. @TemplateHint What kind of field (text, number, date, ...) and additional styles or classes. @Translate For i18n of components","title":"UI Decorators (property level)"},{"location":"md/docs/internals/about/","text":"About # This project was created between 2019 and 2020 by Joerg Krause, Berlin, Germany. I like to introduce myself as an experienced expert especially for Web Technologies such as Angular, React, NodeJs, ASP.NET and common frameworks and systems such as .NET, SQL Server, IIS, and related subjects. I\u2019m a developer, consultant, trainer, and software architect. I work as a freelance senior consultant for enterprises and run a few thrilling projects on my own. To learn more, click in the section \u201acool stuff\u2018 in the right column. To find out more about me feel free to contact me or click \u201acurrent profiles\u2018 at the right. You can contact me in German and English language. I\u2019m available worldwide. A Short Introduction # I work as an software architect and technology consultant, especially around software development on the Microsoft Windows platform. He is focused in main topics such as Web Server development (including all web technologies, like HTML, CSS, JS/AJAX, as well as ASP.NET), SQL Server development (T-SQL, SSIS), and graphical environments (graphical Editors like IE and stuff based on it like Netrix, WPF, Silverlight). I\u2019m certified for several of these technologies and I\u2019m re-certifying regularly. I have published more than 60 books for Apress, Carl Hanser Verlag, Addison Wesley Germany, Markt + Technik and Symposion Publishing and in addition to more than 100 journal articles, notably for the German IT journals iX, DatabasePro, DOTNETpro, and \u201eASP.NET professional\u201c. I regularly speak at professional and scientific conferences (e.g. BASTA, Prio Conference, VSOne, DOTNET Conference, DotnetCologne, PHP Conference, DDC, and several INETA user group meetings). I run several thrilling projects, such as the component development of the Netrix Editor (Made by Guru Components), the software development company Augmented Software and the online publishing company Augmented Content. I\u2019m co-founder and stakeholder of all. If you want to get more information, want to join my network, seeking investment possibilities, or just want to be part of the party you\u2019re invited to contact me. Projects # I'M inventor and maintainer of @nyaf - an advanced Web Components framework. I'm the inventor and maintainer of SVOGV, an extension for Angular that provides dynamic forms, viewmodel decorators, and dynamic validation. Contact # Get me on the web (in German, see English About section).","title":"About"},{"location":"md/docs/internals/about/#about","text":"This project was created between 2019 and 2020 by Joerg Krause, Berlin, Germany. I like to introduce myself as an experienced expert especially for Web Technologies such as Angular, React, NodeJs, ASP.NET and common frameworks and systems such as .NET, SQL Server, IIS, and related subjects. I\u2019m a developer, consultant, trainer, and software architect. I work as a freelance senior consultant for enterprises and run a few thrilling projects on my own. To learn more, click in the section \u201acool stuff\u2018 in the right column. To find out more about me feel free to contact me or click \u201acurrent profiles\u2018 at the right. You can contact me in German and English language. I\u2019m available worldwide.","title":"About"},{"location":"md/docs/internals/about/#a-short-introduction","text":"I work as an software architect and technology consultant, especially around software development on the Microsoft Windows platform. He is focused in main topics such as Web Server development (including all web technologies, like HTML, CSS, JS/AJAX, as well as ASP.NET), SQL Server development (T-SQL, SSIS), and graphical environments (graphical Editors like IE and stuff based on it like Netrix, WPF, Silverlight). I\u2019m certified for several of these technologies and I\u2019m re-certifying regularly. I have published more than 60 books for Apress, Carl Hanser Verlag, Addison Wesley Germany, Markt + Technik and Symposion Publishing and in addition to more than 100 journal articles, notably for the German IT journals iX, DatabasePro, DOTNETpro, and \u201eASP.NET professional\u201c. I regularly speak at professional and scientific conferences (e.g. BASTA, Prio Conference, VSOne, DOTNET Conference, DotnetCologne, PHP Conference, DDC, and several INETA user group meetings). I run several thrilling projects, such as the component development of the Netrix Editor (Made by Guru Components), the software development company Augmented Software and the online publishing company Augmented Content. I\u2019m co-founder and stakeholder of all. If you want to get more information, want to join my network, seeking investment possibilities, or just want to be part of the party you\u2019re invited to contact me.","title":"A Short Introduction"},{"location":"md/docs/internals/about/#projects","text":"I'M inventor and maintainer of @nyaf - an advanced Web Components framework. I'm the inventor and maintainer of SVOGV, an extension for Angular that provides dynamic forms, viewmodel decorators, and dynamic validation.","title":"Projects"},{"location":"md/docs/internals/about/#contact","text":"Get me on the web (in German, see English About section).","title":"Contact"},{"location":"md/docs/internals/lic/","text":"License # MIT License # Copyright (c) 2019 Joerg Krause, joerg@krause.net, www.joergkrause.de Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"md/docs/internals/lic/#license","text":"","title":"License"},{"location":"md/docs/internals/lic/#mit-license","text":"Copyright (c) 2019 Joerg Krause, joerg@krause.net, www.joergkrause.de Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"md/docs/internals/start/","text":"How it's being made # This chapter explains the inner workings and solutions used to create the framework. It's also an journey into ECMAScript beyond the usual usage scenario. The Base Component # This is by far the most complex part. It delivers the support for all the features @nyaf has to offer. Let's look into the inner parts step by step. Web Component # Ctor # Setup / Render # Life Cycle # Data Handling for Attributes # The Decorators # The Router # The router is simple yet powerful. It renders components in the outlet by adding the content to innerHTML . That invokes the component's life cycle. The Binder # The binder is part of @nyaf/forms and a complex piece of code that handles the smart rendering using Proxy objects. The usage of proxies has been criticized by many developers because of the complexity, difficult debugging and hard to follow behavior. They're, however, native functions of ECMAScript and fully supported by browsers. The ability to intercept property calls avoid building a n artificial layer on top of the components. The meain reason here is, that it safes a lot of space and makes the package much smaller.","title":"How it's being made"},{"location":"md/docs/internals/start/#how-its-being-made","text":"This chapter explains the inner workings and solutions used to create the framework. It's also an journey into ECMAScript beyond the usual usage scenario.","title":"How it's being made"},{"location":"md/docs/internals/start/#the-base-component","text":"This is by far the most complex part. It delivers the support for all the features @nyaf has to offer. Let's look into the inner parts step by step.","title":"The Base Component"},{"location":"md/docs/internals/start/#web-component","text":"","title":"Web Component"},{"location":"md/docs/internals/start/#ctor","text":"","title":"Ctor"},{"location":"md/docs/internals/start/#setup-render","text":"","title":"Setup / Render"},{"location":"md/docs/internals/start/#life-cycle","text":"","title":"Life Cycle"},{"location":"md/docs/internals/start/#data-handling-for-attributes","text":"","title":"Data Handling for Attributes"},{"location":"md/docs/internals/start/#the-decorators","text":"","title":"The Decorators"},{"location":"md/docs/internals/start/#the-router","text":"The router is simple yet powerful. It renders components in the outlet by adding the content to innerHTML . That invokes the component's life cycle.","title":"The Router"},{"location":"md/docs/internals/start/#the-binder","text":"The binder is part of @nyaf/forms and a complex piece of code that handles the smart rendering using Proxy objects. The usage of proxies has been criticized by many developers because of the complexity, difficult debugging and hard to follow behavior. They're, however, native functions of ECMAScript and fully supported by browsers. The ability to intercept property calls avoid building a n artificial layer on top of the components. The meain reason here is, that it safes a lot of space and makes the package much smaller.","title":"The Binder"},{"location":"md/docs/lib/attributes/","text":"State and Properties # There is no explicit difference between State and Property. Compared with React it's much more simpler. A state still exists and it supports smart rendering. State # To declare a state object use a generic like this: export class MainComponent extends BaseComponent { cnt: number} { // ... omitted for brevity } The State generic is optional. If there is no state necessary just use any or an empty object such as {} . Now two functions are available: data : Returns the instance of the data object and contains all properties defined in the generic. This is protected and only available within the class. setData : Sets a changed value and, if the value differs, re-renders the component. A simple counter shows how to use: export class CounterComponent extends BaseComponent { cnt: number } { constructor() { super(); super.setData('cnt', 10); } clickMeAdd(v: number) { super.setData('cnt', super.data.cnt + 1); } clickMeSub(v: number) { super.setData('cnt', super.data.cnt - 1); } async render() { return await ( div button type='button' n-on-click={e = this.clickMeAdd(e)} Add 1 /button button type='button' n-on-click={e = this.clickMeSub(e)} Sub 1 /button /div pre style='border: 1px solid gray;' { super.data.cnt } /pre / ); } } Properties # To use properties, you can define those. Each property is automatically part of the state and once it changes, the component re-renders. @CustomElement('app-btn') @Properties { title: string } ({ title: 'Default' }) export class ButtonComponent extends BaseComponent { title: string, cnt: number } { // ... omitted for brevity } The initializer with default's is _not _ optional, you must provide an object that matches the generic. This is how you use such a component (part of the render method): const someTitle='Demo'; return ( app-btn title={someTitle} / ); The @Properties decorator defines all properties, that are now monitored (observed) and hence the value is evaluated and rendered. If the value changes the component renders itself automatically. Accessing Properties # The access with data is internally and externally available. That means, you can retrieve a component and set values like this: (this.querySelector('[data-demo-button]') as any).data.text = 'Some demo data'; As like with setData internally this will trigger the renderer to re-render the content with the new attribute, but in this case from another component. Data Type # Web Components have the restriction that an attribute can transport string values only. This would lead to \"[Object object]\" for other types. @nyaf ** overcomes this restriction with a smart attribute handling. That means the object is being recognized and stringified to JSON. Additionally, a custom attribute with the name \"__name__\" is written. Assume your values is written like shown below: app-comp test={[{ obj : 1}, { obj : 2}]} /app-comp The rendered component would look like this: app-comp test= [{ obj : 1}, { obj : 2}] __test__ /app-comp Apparently the double double quotes work just fine. However, the content is now a string. If you do operations on this it will not resolve as the array it was before. Here the second attribute will trigger a different behavior. The hook for the data Proxy used internally is now applying a JSON.parse and returns the former object. Also, once set again, the incoming value is checked for being an object and stringified, then. The technique currently works for string (default Web Component behavior), number , boolean , array , and object . For extremely huge complex objects this technique might produce a performance penalty due to repeatedly used JSON.parse / JSON.stringify calls. Be also aware that this cannot work if the object has recursive structures, because the JSON class cannot deal with this. There is no additional error handling to keep the code small, it's just a try/catch block that reports the native error. Properties and View Models # For a nice view decorators applied to class properties control the appearance. export class Model { id: number = 0; name: string = ''; } @CustomElement('app-main') @Properties { data: Model } () export class MainComponent extends BaseComponent { // ... omitted for brevity } Within the component, this is now present. In the above definition super.data contains an actual model.","title":"Attributes"},{"location":"md/docs/lib/attributes/#state-and-properties","text":"There is no explicit difference between State and Property. Compared with React it's much more simpler. A state still exists and it supports smart rendering.","title":"State and Properties"},{"location":"md/docs/lib/attributes/#state","text":"To declare a state object use a generic like this: export class MainComponent extends BaseComponent { cnt: number} { // ... omitted for brevity } The State generic is optional. If there is no state necessary just use any or an empty object such as {} . Now two functions are available: data : Returns the instance of the data object and contains all properties defined in the generic. This is protected and only available within the class. setData : Sets a changed value and, if the value differs, re-renders the component. A simple counter shows how to use: export class CounterComponent extends BaseComponent { cnt: number } { constructor() { super(); super.setData('cnt', 10); } clickMeAdd(v: number) { super.setData('cnt', super.data.cnt + 1); } clickMeSub(v: number) { super.setData('cnt', super.data.cnt - 1); } async render() { return await ( div button type='button' n-on-click={e = this.clickMeAdd(e)} Add 1 /button button type='button' n-on-click={e = this.clickMeSub(e)} Sub 1 /button /div pre style='border: 1px solid gray;' { super.data.cnt } /pre / ); } }","title":"State"},{"location":"md/docs/lib/attributes/#properties","text":"To use properties, you can define those. Each property is automatically part of the state and once it changes, the component re-renders. @CustomElement('app-btn') @Properties { title: string } ({ title: 'Default' }) export class ButtonComponent extends BaseComponent { title: string, cnt: number } { // ... omitted for brevity } The initializer with default's is _not _ optional, you must provide an object that matches the generic. This is how you use such a component (part of the render method): const someTitle='Demo'; return ( app-btn title={someTitle} / ); The @Properties decorator defines all properties, that are now monitored (observed) and hence the value is evaluated and rendered. If the value changes the component renders itself automatically.","title":"Properties"},{"location":"md/docs/lib/attributes/#accessing-properties","text":"The access with data is internally and externally available. That means, you can retrieve a component and set values like this: (this.querySelector('[data-demo-button]') as any).data.text = 'Some demo data'; As like with setData internally this will trigger the renderer to re-render the content with the new attribute, but in this case from another component.","title":"Accessing Properties"},{"location":"md/docs/lib/attributes/#data-type","text":"Web Components have the restriction that an attribute can transport string values only. This would lead to \"[Object object]\" for other types. @nyaf ** overcomes this restriction with a smart attribute handling. That means the object is being recognized and stringified to JSON. Additionally, a custom attribute with the name \"__name__\" is written. Assume your values is written like shown below: app-comp test={[{ obj : 1}, { obj : 2}]} /app-comp The rendered component would look like this: app-comp test= [{ obj : 1}, { obj : 2}] __test__ /app-comp Apparently the double double quotes work just fine. However, the content is now a string. If you do operations on this it will not resolve as the array it was before. Here the second attribute will trigger a different behavior. The hook for the data Proxy used internally is now applying a JSON.parse and returns the former object. Also, once set again, the incoming value is checked for being an object and stringified, then. The technique currently works for string (default Web Component behavior), number , boolean , array , and object . For extremely huge complex objects this technique might produce a performance penalty due to repeatedly used JSON.parse / JSON.stringify calls. Be also aware that this cannot work if the object has recursive structures, because the JSON class cannot deal with this. There is no additional error handling to keep the code small, it's just a try/catch block that reports the native error.","title":"Data Type"},{"location":"md/docs/lib/attributes/#properties-and-view-models","text":"For a nice view decorators applied to class properties control the appearance. export class Model { id: number = 0; name: string = ''; } @CustomElement('app-main') @Properties { data: Model } () export class MainComponent extends BaseComponent { // ... omitted for brevity } Within the component, this is now present. In the above definition super.data contains an actual model.","title":"Properties and View Models"},{"location":"md/docs/lib/configuration/","text":"Configuration # A @nyaf application consists of: An entry file for registering components, typically called main.ts At least one root component The index.html file the browser loads first The configuration for TypeScript, tsconfig.json The Packer / Builder setup; The best choice is probably WebPack, in that case a webpack.config.js file is recommended To get a new project quickly you can use Yeoman and the various generators explained here Entry File # The browser starts here and the basics structure looks like this: The recommended folder structure looks like this: | \\--\\src | |-- index.html | |-- main.ts | \\-- \\components | | | | | \\-- main.component.tsx | | | \\-- \\assets | |-- webpack.config.js |-- tsconfig.json TypeScript Configuration # The TypeScript configuration is typical, but two things are crucial to know: You need to compile with the target \"es2015\" (minimum). ES 5 is explicitly not supported anymore. The template language is a variety of JSX, so the setting \"jsx\" and \"reactNamespace\" are required. @nyaf does not use React, has no relation to React and has almost nothing in common. The setting just tricks the compiler to transpile the templates. { compilerOptions : { target : es2015 , // The target must be at least ES 2015 module : commonjs , moduleResolution : node , resolveJsonModule : true, sourceMap : true, lib : [ es2018 , es5 , dom ], jsx : react , // tell the compiler to accept JSX reactNamespace : JSX , // the name of the support class in @nyaf (this IS mandatory) declaration : false, experimentalDecorators : true, noImplicitAny : false, suppressImplicitAnyIndexErrors : true, removeComments : false, outDir : out-tsc , baseUrl : ./src , typeRoots : [ node_modules/@types , src/types ] }, files : [ ./src/main.ts ] } WebPack Configuration # WebPack is the recommended packer tool, but you can use any other if you like. There is no dependency. A typical configuration will look like this: const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CopyWebpackPlugin = require('copy-webpack-plugin'); const tsconfig = require('./tsconfig.json'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { 'app': './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(png|jpeg)$/, loader: 'url-loader?limit=8192'}, { test: /\\.(woff|woff2)$/, loader: 'file-loader' } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./wwwroot'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Configure whether to polyfill or mock certain Node.js globals and modules node: { __dirname: false }, // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig), new CopyWebpackPlugin([ { from: './src/assets/images', flatten: true, to: './assets/images/' } ]) ] }; // Export the config module.exports = webpackConfig;","title":"Project Configuration"},{"location":"md/docs/lib/configuration/#configuration","text":"A @nyaf application consists of: An entry file for registering components, typically called main.ts At least one root component The index.html file the browser loads first The configuration for TypeScript, tsconfig.json The Packer / Builder setup; The best choice is probably WebPack, in that case a webpack.config.js file is recommended To get a new project quickly you can use Yeoman and the various generators explained here","title":"Configuration"},{"location":"md/docs/lib/configuration/#entry-file","text":"The browser starts here and the basics structure looks like this: The recommended folder structure looks like this: | \\--\\src | |-- index.html | |-- main.ts | \\-- \\components | | | | | \\-- main.component.tsx | | | \\-- \\assets | |-- webpack.config.js |-- tsconfig.json","title":"Entry File"},{"location":"md/docs/lib/configuration/#typescript-configuration","text":"The TypeScript configuration is typical, but two things are crucial to know: You need to compile with the target \"es2015\" (minimum). ES 5 is explicitly not supported anymore. The template language is a variety of JSX, so the setting \"jsx\" and \"reactNamespace\" are required. @nyaf does not use React, has no relation to React and has almost nothing in common. The setting just tricks the compiler to transpile the templates. { compilerOptions : { target : es2015 , // The target must be at least ES 2015 module : commonjs , moduleResolution : node , resolveJsonModule : true, sourceMap : true, lib : [ es2018 , es5 , dom ], jsx : react , // tell the compiler to accept JSX reactNamespace : JSX , // the name of the support class in @nyaf (this IS mandatory) declaration : false, experimentalDecorators : true, noImplicitAny : false, suppressImplicitAnyIndexErrors : true, removeComments : false, outDir : out-tsc , baseUrl : ./src , typeRoots : [ node_modules/@types , src/types ] }, files : [ ./src/main.ts ] }","title":"TypeScript Configuration"},{"location":"md/docs/lib/configuration/#webpack-configuration","text":"WebPack is the recommended packer tool, but you can use any other if you like. There is no dependency. A typical configuration will look like this: const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CopyWebpackPlugin = require('copy-webpack-plugin'); const tsconfig = require('./tsconfig.json'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { 'app': './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(png|jpeg)$/, loader: 'url-loader?limit=8192'}, { test: /\\.(woff|woff2)$/, loader: 'file-loader' } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./wwwroot'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Configure whether to polyfill or mock certain Node.js globals and modules node: { __dirname: false }, // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig), new CopyWebpackPlugin([ { from: './src/assets/images', flatten: true, to: './assets/images/' } ]) ] }; // Export the config module.exports = webpackConfig;","title":"WebPack Configuration"},{"location":"md/docs/lib/events/","text":"Events # Events are defined by a special instruction. They are attached to document object, regardless the usage. n-on-[event] # Events are easy to add directly using it like n-on-click . All JavaScript events are supported. Just replace 'click' in the example with any other JavaScript event. button n-on-click={() = this.clickMe()} OK /button There is no bind necessary, events are bound to components anyway. You can get the (original HTML 5 API) event using a parameter, like e in the example below: button n-on-click={(e) = this.clickMe(e)} OK /button There is an alternative syntax that takes the method name directly (note that here are single quotes being used instead of curly braces): button n-on-click={this.clickMe} OK /button The method is bound with or without the event object as a parameter, hence the method can have a parameter like this: clickMe(e?: Event) { } The Event type conforms to HTML 5 DOM. Replace according the attached event ( MouseEvent etc., see here for details). Syntax Enhancements # Short Form # If you don't need access to the parameter of the event (example: a click, which just happens), the a short form is possible: button type= button n-on-click={this.clickMe} Additional Parameters # You can add constant values like this: button type= button n-on-click={(e) = this.clickMe(e, 'PROP')} Warning! Regardless the type, the received value will be a string type at runtime. button type= button n-on-click={(e) = this.clickMe(e, 100)} This works, but the function will receive \"100\". button type= button n-on-click={(e) = this.clickMe(e, 1 + 2)} This works, too, but the function will receive \"1 + 2\". The expression is not being executed! So, this is somehow limited in the current version. You can add multiple parameters, though. button type= button n-on-click={(e) = this.clickMe(e, 1, 2)} clickMe(e: Event, a: string, b: string) { const r = +a + +b; } Usually, it doesn't make sense to have calculation on constant values. So in reality this isn't a serious limitation. Async # You can combine any event with the attribute n-async to make the call to the event's handler function async. This attribute does not take any parameters. The handler method must not be decorated with async . button n-on-click={this.clickMe} n-async OK /button Custom Events # Sometimes the JavaScript events are not flexible enough. So you can define your own ones. That's done by three simple steps: Add a decorator @Events to declare the events (it's an array to declare multiple in one step). Mandatory. Create CustomEventInit object and dispatch (that's native Web Component behavior ) use the n-on- myCustomEventName attribute to attach the event. Imagine a button component like this: @CustomElement('app-button') @Events(['showAlert']) export class ButtonComponent extends BaseComponent { constructor() { super(); } clickMe() { const checkEvent: CustomEventInit = { bubbles: true, cancelable: false, }; super.dispatch('showAlert', checkEvent); } async render() { return await ( button type= button n-on-click={this.clickMe} Demo /button ); } } The custom event in this example is called showAlert . It's invoked by a click. The element's host component has code like this: app-button n-on-showAlert={(e) = this.someHandler(e)} / The argument e contains an CustomEvent object. It can carry any number of custom data. The click -invoker is just an example, any action can call a custom event, even a web socket callback, a timer, or an HTTP request result. Both CustomEvent and CustomEventInit have a field detail that can carry any object or scalar and is the proposed way to transport custom data with the event. The event handler could look like this: private showAlert(e: CustomEvent) { const data = e.detail; // Your code that handles the event } Custom events can be async, too. Just add n-async to the element that fires the event and add the async modifier to the handler.","title":"Events"},{"location":"md/docs/lib/events/#events","text":"Events are defined by a special instruction. They are attached to document object, regardless the usage.","title":"Events"},{"location":"md/docs/lib/events/#n-on-event","text":"Events are easy to add directly using it like n-on-click . All JavaScript events are supported. Just replace 'click' in the example with any other JavaScript event. button n-on-click={() = this.clickMe()} OK /button There is no bind necessary, events are bound to components anyway. You can get the (original HTML 5 API) event using a parameter, like e in the example below: button n-on-click={(e) = this.clickMe(e)} OK /button There is an alternative syntax that takes the method name directly (note that here are single quotes being used instead of curly braces): button n-on-click={this.clickMe} OK /button The method is bound with or without the event object as a parameter, hence the method can have a parameter like this: clickMe(e?: Event) { } The Event type conforms to HTML 5 DOM. Replace according the attached event ( MouseEvent etc., see here for details).","title":"n-on-[event]"},{"location":"md/docs/lib/events/#syntax-enhancements","text":"","title":"Syntax Enhancements"},{"location":"md/docs/lib/events/#short-form","text":"If you don't need access to the parameter of the event (example: a click, which just happens), the a short form is possible: button type= button n-on-click={this.clickMe}","title":"Short Form"},{"location":"md/docs/lib/events/#additional-parameters","text":"You can add constant values like this: button type= button n-on-click={(e) = this.clickMe(e, 'PROP')} Warning! Regardless the type, the received value will be a string type at runtime. button type= button n-on-click={(e) = this.clickMe(e, 100)} This works, but the function will receive \"100\". button type= button n-on-click={(e) = this.clickMe(e, 1 + 2)} This works, too, but the function will receive \"1 + 2\". The expression is not being executed! So, this is somehow limited in the current version. You can add multiple parameters, though. button type= button n-on-click={(e) = this.clickMe(e, 1, 2)} clickMe(e: Event, a: string, b: string) { const r = +a + +b; } Usually, it doesn't make sense to have calculation on constant values. So in reality this isn't a serious limitation.","title":"Additional Parameters"},{"location":"md/docs/lib/events/#async","text":"You can combine any event with the attribute n-async to make the call to the event's handler function async. This attribute does not take any parameters. The handler method must not be decorated with async . button n-on-click={this.clickMe} n-async OK /button","title":"Async"},{"location":"md/docs/lib/events/#custom-events","text":"Sometimes the JavaScript events are not flexible enough. So you can define your own ones. That's done by three simple steps: Add a decorator @Events to declare the events (it's an array to declare multiple in one step). Mandatory. Create CustomEventInit object and dispatch (that's native Web Component behavior ) use the n-on- myCustomEventName attribute to attach the event. Imagine a button component like this: @CustomElement('app-button') @Events(['showAlert']) export class ButtonComponent extends BaseComponent { constructor() { super(); } clickMe() { const checkEvent: CustomEventInit = { bubbles: true, cancelable: false, }; super.dispatch('showAlert', checkEvent); } async render() { return await ( button type= button n-on-click={this.clickMe} Demo /button ); } } The custom event in this example is called showAlert . It's invoked by a click. The element's host component has code like this: app-button n-on-showAlert={(e) = this.someHandler(e)} / The argument e contains an CustomEvent object. It can carry any number of custom data. The click -invoker is just an example, any action can call a custom event, even a web socket callback, a timer, or an HTTP request result. Both CustomEvent and CustomEventInit have a field detail that can carry any object or scalar and is the proposed way to transport custom data with the event. The event handler could look like this: private showAlert(e: CustomEvent) { const data = e.detail; // Your code that handles the event } Custom events can be async, too. Just add n-async to the element that fires the event and add the async modifier to the handler.","title":"Custom Events"},{"location":"md/docs/lib/jsx/","text":"JSX / TSX # Fundamentally, JSX just provides syntactic sugar for the JSX.createElement(component, props, ...children) function. In @nyaf we use only the TSX variant. That means, the transformation and conversion to JavaScript is made by the TypeScript transpiler. Be aware, that while the main framework with JSX built-in is React, @nyaf has absolutely no relation to React, and the behavior of the code is different. Introduction # The example assume that some code surrounds the snippets or is just the return value of the render() method. The TSX code: my-button color= blue shadowSize={2} Click Me /my-button compiles into: JSX.createElement( 'my-button', {color: 'blue', shadowSize: 2}, 'Click Me' ) JSX Scope # Since JSX compiles into calls to JSX.createElement , the JSX class must also always be in scope from your TSX code. For example, both of the imports are necessary in this code, even though React and CustomButton are not directly referenced from JavaScript: import JSX from '@nyaf/lib'; // code omitted for brevity async render() { // return JSX.createElement('custom-button', {color: 'red'}, null); return await ( custom-button color= red / ); } It's a default export, so no curly braces here! If you don\u2019t use a JavaScript bundler and loaded @nyaf from a script tag, it is already in scope as the JSX global. The elements used in the TSX parts are registered globally and there is no additional import required. That's a fundamentally different behavior in comparison to React. In React the first argument is a type and the elements will render itself based on the given type. In @nyaf the first argument is a string, and the constructed element is pushed to the browser as string through innerHTML , and the browser renders the content directly using native code. Examples # You can also use the self-closing form of the tag if there are no children. So: div className= sidebar / compiles into: JSX.createElement( 'div', {className: 'sidebar'} ) If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler. Specifying The Element Type # The first part of a TSX tag determines the type of the element. It's the name of a registered Web Component. User-Defined Components Must Be in Kebap Style # When an element type starts with a lowercase letter, it refers to a built-in component like div or span and results in a string 'div' or 'span' passed to JSX.createElement. Types that have a dashed name like compile to JSX.createElement('my-foo') and correspond to a component defined globally through GlobalProvider . We recommend naming components always with kebap style. Props in TSX # There are several different ways to specify props in TSX. JavaScript Expressions as Props # You can pass any JavaScript expression as a prop, by surrounding it with {} . For example, in this TSX: my-component foo={1 + 2 + 3 + 4} / For 'my-component', the value of props.foo will be 10 because the expression 1 + 2 + 3 + 4 gets evaluated. if statements and for loops are not expressions in JavaScript, so they can\u2019t be used in TSX directly. Instead, you can put these in the surrounding code. For example: function NumberDescriber(props) { let description; if (props.number % 2 == 0) { description = strong even /strong ; } else { description = i odd /i ; } return ( div {props.number} is an {description} number /div ); } You can learn more about conditional rendering and loops in the corresponding sections. String Literals # You can pass a string literal as a prop. These two JSX expressions are equivalent: my-component message= hello world / my-component message={'hello world'} / When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent: my-component message= lt;3 / my-component message={' 3'} / This behavior is usually not relevant. It\u2019s only mentioned here for completeness. Props Default to \u201cTrue\u201d # If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent: my-textbox autocomplete / my-textbox autocomplete={true} / In general, we don\u2019t recommend not passing a value for a prop, because it can be confused with the ES6 object shorthand {foo} which is short for {foo: foo} rather than {foo: true}. This behavior is just there so that it matches the behavior of HTML. Spread Attributes # If you already have props as an object, and you want to pass it in JSX, you can use ... as a \u201cspread\u201d operator to pass the whole props object. These two components are equivalent: function App1() { return app-greeting firstName= Ben lastName= Hector / ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return app-greeting {...props} / ; } You can also pick specific props that your component will consume while passing all other props using the spread operator. const Button = props = { const { kind, ...other } = props; const className = kind === primary ? PrimaryButton : SecondaryButton ; return button className={className} {...other} / ; }; const App = () = { return ( div Button kind= primary onClick={() = console.log( clicked! )} Hello World! /Button /div ); }; In the example above, the kind prop is safely consumed and is not passed on to the button element in the DOM. All other props are passed via the ...other object making this component really flexible. You can see that it passes an onClick and children props. Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don\u2019t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly. Children in TSX # In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. There are several different ways to pass children: String Literals # You can put a string between the opening and closing tags and props.children will just be that string. This is useful for many of the built-in HTML elements. For example: my-component Hello world! /MyComponent This is valid JSX, and props.children in MyComponent will simply be the string \"Hello world!\". HTML is unescaped, so you can generally write JSX just like you would write HTML in this way: div This is valid HTML amp; JSX at the same time. /div JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing: div Hello World /div div Hello World /div div Hello World /div div Hello World /div JSX Children # You can provide more JSX elements as the children. This is useful for displaying nested components: MyContainer MyFirstComponent / MySecondComponent / /MyContainer You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML: div Here is a list: ul li Item 1 /li li Item 2 /li /ul /div A React component can also return an array of elements: render() { // No need to wrap list items in an extra element! return [ // Don't forget the keys :) li key= A First item /li , li key= B Second item /li , li key= C Third item /li , ]; } JavaScript Expressions as Children # You can pass any JavaScript expression as children, by enclosing it within {}. For example, these expressions are equivalent: my-component foo /MyComponent my-component {'foo'} /MyComponent This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list: function Item(props) { return li {props.message} /li ; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( ul {todos.map((message) = Item key={message} message={message} / )} /ul ); } JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates: function Hello(props) { return div Hello {props.addressee}! /div ; } Functions as Children # Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, props.children works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as props.children: // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i props.numTimes; i++) { items.push(props.children(i)); } return div {items} /div ; } function ListOfTenThings() { return ( Repeat numTimes={10} {(index) = div key={index} This is item {index} in the list /div } /Repeat ); } Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of. Booleans, Null, and Undefined Are Ignored false, null, undefined, and true are valid children. They simply don\u2019t render. These JSX expressions will all render to the same thing: div / div /div div {false} /div div {null} /div div {undefined} /div div {true} /div This can be useful to conditionally render React elements. This JSX renders the component only if showHeader is true: div {showHeader Header / } Content / /div One caveat is that some \u201cfalsy\u201d values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when props.messages is an empty array: div {props.messages.length MessageList messages={props.messages} / } /div To fix this, make sure that the expression before is always boolean: div {props.messages.length 0 MessageList messages={props.messages} / } /div Conversely, if you want a value like false, true, null, or undefined to appear in the output, you have to convert it to a string first: div My JavaScript variable is {String(myVariable)}. /div","title":"JSX / TSX"},{"location":"md/docs/lib/jsx/#jsx-tsx","text":"Fundamentally, JSX just provides syntactic sugar for the JSX.createElement(component, props, ...children) function. In @nyaf we use only the TSX variant. That means, the transformation and conversion to JavaScript is made by the TypeScript transpiler. Be aware, that while the main framework with JSX built-in is React, @nyaf has absolutely no relation to React, and the behavior of the code is different.","title":"JSX / TSX"},{"location":"md/docs/lib/jsx/#introduction","text":"The example assume that some code surrounds the snippets or is just the return value of the render() method. The TSX code: my-button color= blue shadowSize={2} Click Me /my-button compiles into: JSX.createElement( 'my-button', {color: 'blue', shadowSize: 2}, 'Click Me' )","title":"Introduction"},{"location":"md/docs/lib/jsx/#jsx-scope","text":"Since JSX compiles into calls to JSX.createElement , the JSX class must also always be in scope from your TSX code. For example, both of the imports are necessary in this code, even though React and CustomButton are not directly referenced from JavaScript: import JSX from '@nyaf/lib'; // code omitted for brevity async render() { // return JSX.createElement('custom-button', {color: 'red'}, null); return await ( custom-button color= red / ); } It's a default export, so no curly braces here! If you don\u2019t use a JavaScript bundler and loaded @nyaf from a script tag, it is already in scope as the JSX global. The elements used in the TSX parts are registered globally and there is no additional import required. That's a fundamentally different behavior in comparison to React. In React the first argument is a type and the elements will render itself based on the given type. In @nyaf the first argument is a string, and the constructed element is pushed to the browser as string through innerHTML , and the browser renders the content directly using native code.","title":"JSX Scope"},{"location":"md/docs/lib/jsx/#examples","text":"You can also use the self-closing form of the tag if there are no children. So: div className= sidebar / compiles into: JSX.createElement( 'div', {className: 'sidebar'} ) If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler.","title":"Examples"},{"location":"md/docs/lib/jsx/#specifying-the-element-type","text":"The first part of a TSX tag determines the type of the element. It's the name of a registered Web Component.","title":"Specifying The Element Type"},{"location":"md/docs/lib/jsx/#user-defined-components-must-be-in-kebap-style","text":"When an element type starts with a lowercase letter, it refers to a built-in component like div or span and results in a string 'div' or 'span' passed to JSX.createElement. Types that have a dashed name like compile to JSX.createElement('my-foo') and correspond to a component defined globally through GlobalProvider . We recommend naming components always with kebap style.","title":"User-Defined Components Must Be in Kebap Style"},{"location":"md/docs/lib/jsx/#props-in-tsx","text":"There are several different ways to specify props in TSX.","title":"Props in TSX"},{"location":"md/docs/lib/jsx/#javascript-expressions-as-props","text":"You can pass any JavaScript expression as a prop, by surrounding it with {} . For example, in this TSX: my-component foo={1 + 2 + 3 + 4} / For 'my-component', the value of props.foo will be 10 because the expression 1 + 2 + 3 + 4 gets evaluated. if statements and for loops are not expressions in JavaScript, so they can\u2019t be used in TSX directly. Instead, you can put these in the surrounding code. For example: function NumberDescriber(props) { let description; if (props.number % 2 == 0) { description = strong even /strong ; } else { description = i odd /i ; } return ( div {props.number} is an {description} number /div ); } You can learn more about conditional rendering and loops in the corresponding sections.","title":"JavaScript Expressions as Props"},{"location":"md/docs/lib/jsx/#string-literals","text":"You can pass a string literal as a prop. These two JSX expressions are equivalent: my-component message= hello world / my-component message={'hello world'} / When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent: my-component message= lt;3 / my-component message={' 3'} / This behavior is usually not relevant. It\u2019s only mentioned here for completeness.","title":"String Literals"},{"location":"md/docs/lib/jsx/#props-default-to-true","text":"If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent: my-textbox autocomplete / my-textbox autocomplete={true} / In general, we don\u2019t recommend not passing a value for a prop, because it can be confused with the ES6 object shorthand {foo} which is short for {foo: foo} rather than {foo: true}. This behavior is just there so that it matches the behavior of HTML.","title":"Props Default to \u201cTrue\u201d"},{"location":"md/docs/lib/jsx/#spread-attributes","text":"If you already have props as an object, and you want to pass it in JSX, you can use ... as a \u201cspread\u201d operator to pass the whole props object. These two components are equivalent: function App1() { return app-greeting firstName= Ben lastName= Hector / ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return app-greeting {...props} / ; } You can also pick specific props that your component will consume while passing all other props using the spread operator. const Button = props = { const { kind, ...other } = props; const className = kind === primary ? PrimaryButton : SecondaryButton ; return button className={className} {...other} / ; }; const App = () = { return ( div Button kind= primary onClick={() = console.log( clicked! )} Hello World! /Button /div ); }; In the example above, the kind prop is safely consumed and is not passed on to the button element in the DOM. All other props are passed via the ...other object making this component really flexible. You can see that it passes an onClick and children props. Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don\u2019t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly.","title":"Spread Attributes"},{"location":"md/docs/lib/jsx/#children-in-tsx","text":"In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. There are several different ways to pass children:","title":"Children in TSX"},{"location":"md/docs/lib/jsx/#string-literals_1","text":"You can put a string between the opening and closing tags and props.children will just be that string. This is useful for many of the built-in HTML elements. For example: my-component Hello world! /MyComponent This is valid JSX, and props.children in MyComponent will simply be the string \"Hello world!\". HTML is unescaped, so you can generally write JSX just like you would write HTML in this way: div This is valid HTML amp; JSX at the same time. /div JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing: div Hello World /div div Hello World /div div Hello World /div div Hello World /div","title":"String Literals"},{"location":"md/docs/lib/jsx/#jsx-children","text":"You can provide more JSX elements as the children. This is useful for displaying nested components: MyContainer MyFirstComponent / MySecondComponent / /MyContainer You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML: div Here is a list: ul li Item 1 /li li Item 2 /li /ul /div A React component can also return an array of elements: render() { // No need to wrap list items in an extra element! return [ // Don't forget the keys :) li key= A First item /li , li key= B Second item /li , li key= C Third item /li , ]; }","title":"JSX Children"},{"location":"md/docs/lib/jsx/#javascript-expressions-as-children","text":"You can pass any JavaScript expression as children, by enclosing it within {}. For example, these expressions are equivalent: my-component foo /MyComponent my-component {'foo'} /MyComponent This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list: function Item(props) { return li {props.message} /li ; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( ul {todos.map((message) = Item key={message} message={message} / )} /ul ); } JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates: function Hello(props) { return div Hello {props.addressee}! /div ; }","title":"JavaScript Expressions as Children"},{"location":"md/docs/lib/jsx/#functions-as-children","text":"Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, props.children works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as props.children: // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i props.numTimes; i++) { items.push(props.children(i)); } return div {items} /div ; } function ListOfTenThings() { return ( Repeat numTimes={10} {(index) = div key={index} This is item {index} in the list /div } /Repeat ); } Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of. Booleans, Null, and Undefined Are Ignored false, null, undefined, and true are valid children. They simply don\u2019t render. These JSX expressions will all render to the same thing: div / div /div div {false} /div div {null} /div div {undefined} /div div {true} /div This can be useful to conditionally render React elements. This JSX renders the component only if showHeader is true: div {showHeader Header / } Content / /div One caveat is that some \u201cfalsy\u201d values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when props.messages is an empty array: div {props.messages.length MessageList messages={props.messages} / } /div To fix this, make sure that the expression before is always boolean: div {props.messages.length 0 MessageList messages={props.messages} / } /div Conversely, if you want a value like false, true, null, or undefined to appear in the output, you have to convert it to a string first: div My JavaScript variable is {String(myVariable)}. /div","title":"Functions as Children"},{"location":"md/docs/lib/lifecycle/","text":"Life Cycle # Components have a life cycle. Instead of several events, there is just one method you must override (or ignore if not needed): lifeCycle(cycle: LifeCycle){ if (cycle === LifeCycle.Load){ // it's ready to go } } Note, that the method has lower case \"l\". The LifeCycle -enum (upper case \"L\") has these fields: Init : Start, ctor is being called. Connect : Component connects to backend SetData : A change in the data object occurred. Load : The render process is done and the component has been loaded PreRender : The render method has been called and content is written to innerHTML . Disconnect : Component is going to be unloaded. Disposed : After calling the dispose method. The life cycle is available through an event lifecycle . It's exposed via a property called onlifecycle on the element level, too. The events are fired after the internal hook has been called.","title":"Life Cycle"},{"location":"md/docs/lib/lifecycle/#life-cycle","text":"Components have a life cycle. Instead of several events, there is just one method you must override (or ignore if not needed): lifeCycle(cycle: LifeCycle){ if (cycle === LifeCycle.Load){ // it's ready to go } } Note, that the method has lower case \"l\". The LifeCycle -enum (upper case \"L\") has these fields: Init : Start, ctor is being called. Connect : Component connects to backend SetData : A change in the data object occurred. Load : The render process is done and the component has been loaded PreRender : The render method has been called and content is written to innerHTML . Disconnect : Component is going to be unloaded. Disposed : After calling the dispose method. The life cycle is available through an event lifecycle . It's exposed via a property called onlifecycle on the element level, too. The events are fired after the internal hook has been called.","title":"Life Cycle"},{"location":"md/docs/lib/overview/","text":"Components # Components are the core ingredients. You write components as classes, decorated with the decorator CustomElement . This defines a Web Component . The Component must be registered, then. This is done by calling the static method GlobalProvider.bootstrap . Registration Support # Web Components must be registered. To support this, we use decorators. This makes it quite easy to define a component without knowing the details of the browser's API. The name is determined by @CustomElement('my-name') . This is mandatory. Note the base class, which gets a generic that later controls the attributes. The name shall follow the common rules of Web Components, that means, it must have at least one dash '-' so there is no risk of a collision with common HTML element names. import JSX, { CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent {} { constructor() { super(); } async render() { return await ( h1 Demo /h1 / ); } } Let's go step by step through this simple component. First, the import includes not only the decorator, but the type JSX too. That's necessary, if you want to use JSX (or TSX) and let the TypeScript compiler translate the HTML syntax properly. The supporting class comes from @nyaf/lib and has absolutely no relation to React. It has, in some details, a different behavior. The import is necessary, even if there is no explicit usage in the module. Both, the TypeScript transpiler and linter such as TSLInt know about this and will not complain. Second, the component has a base class. All @nyaf components are derived from HTMLElement . Currently we don't support inheriting from other element types. Now, that the component is defined, it must be registered. In a file called main.ts (or wherever your app is bootstrapped) call this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent] }); That's it, the component works now. Use it in the HTML part: body class= container app-main /app-main /body Once you have more components, it may look like this: GlobalProvider.bootstrap({ components: [ ButtonComponent, TabComponent, TabsComponent, MainComponent] }); The main goal is to add template features to the JSX part. How to use # This section describes setup and first steps. Prepare a project # Install the package: npm i @nyaf/lib -S Create a file main.ts in the src folder that looks like this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './main.component'; GlobalProvider.bootstrap({ components: [MainComponent], }); Create file main.component.tsx in the same folder (It must be *.tsx !). Fill this content in: import JSX, { BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { constructor() { super(); } async render() { return await ( section h2 Demo /h2 p Hello nyaf /p /section ); } } Watch the default import for JSX - this IS required, even if there is no explicit call. The TypeScript transpiler needs this when handling JSX files. It's always JSX , even if we use *.tsx -files. Create a file named index.html in the very same folder and fill it like this: !DOCTYPE html html lang= en head meta charset= UTF-8 meta name= viewport content= width=device-width, initial-scale=1.0 meta http-equiv= X-UA-Compatible content= ie=edge title Hello nyaf /title /head body h1 Hello nyaf /h1 app-main /app-main /body /html Your app starts in line 11.","title":"Overview"},{"location":"md/docs/lib/overview/#components","text":"Components are the core ingredients. You write components as classes, decorated with the decorator CustomElement . This defines a Web Component . The Component must be registered, then. This is done by calling the static method GlobalProvider.bootstrap .","title":"Components"},{"location":"md/docs/lib/overview/#registration-support","text":"Web Components must be registered. To support this, we use decorators. This makes it quite easy to define a component without knowing the details of the browser's API. The name is determined by @CustomElement('my-name') . This is mandatory. Note the base class, which gets a generic that later controls the attributes. The name shall follow the common rules of Web Components, that means, it must have at least one dash '-' so there is no risk of a collision with common HTML element names. import JSX, { CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent {} { constructor() { super(); } async render() { return await ( h1 Demo /h1 / ); } } Let's go step by step through this simple component. First, the import includes not only the decorator, but the type JSX too. That's necessary, if you want to use JSX (or TSX) and let the TypeScript compiler translate the HTML syntax properly. The supporting class comes from @nyaf/lib and has absolutely no relation to React. It has, in some details, a different behavior. The import is necessary, even if there is no explicit usage in the module. Both, the TypeScript transpiler and linter such as TSLInt know about this and will not complain. Second, the component has a base class. All @nyaf components are derived from HTMLElement . Currently we don't support inheriting from other element types. Now, that the component is defined, it must be registered. In a file called main.ts (or wherever your app is bootstrapped) call this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent] }); That's it, the component works now. Use it in the HTML part: body class= container app-main /app-main /body Once you have more components, it may look like this: GlobalProvider.bootstrap({ components: [ ButtonComponent, TabComponent, TabsComponent, MainComponent] }); The main goal is to add template features to the JSX part.","title":"Registration Support"},{"location":"md/docs/lib/overview/#how-to-use","text":"This section describes setup and first steps.","title":"How to use"},{"location":"md/docs/lib/overview/#prepare-a-project","text":"Install the package: npm i @nyaf/lib -S Create a file main.ts in the src folder that looks like this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './main.component'; GlobalProvider.bootstrap({ components: [MainComponent], }); Create file main.component.tsx in the same folder (It must be *.tsx !). Fill this content in: import JSX, { BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { constructor() { super(); } async render() { return await ( section h2 Demo /h2 p Hello nyaf /p /section ); } } Watch the default import for JSX - this IS required, even if there is no explicit call. The TypeScript transpiler needs this when handling JSX files. It's always JSX , even if we use *.tsx -files. Create a file named index.html in the very same folder and fill it like this: !DOCTYPE html html lang= en head meta charset= UTF-8 meta name= viewport content= width=device-width, initial-scale=1.0 meta http-equiv= X-UA-Compatible content= ie=edge title Hello nyaf /title /head body h1 Hello nyaf /h1 app-main /app-main /body /html Your app starts in line 11.","title":"Prepare a project"},{"location":"md/docs/lib/router/","text":"Router # Usually we create SPAs (Single Page Apps). Hence we need a router. The included router is very simple. First, define an outlet where the components appear: div n-router-outlet /div Any kind of parent element will do. The router code sets the property innerHTML . Components, that are being used to provide router content need registration too. They must have a name, too, because that's the way the router internally activates the component. There is just one default outlet. See further below for using named outlets. Register Routes # The following code shows how to register routes: let routes = { '/': { component: DemoComponent }, '/about': { component: AboutComponent }, '/demo': { component: DemoComponent }, '/contact': { component: ContactComponent }, '**': { component: DemoComponent } }; GlobalProvider.bootstrap({ components: [DemoComponent, AboutComponent, ContactComponent, MainComponent], routes: routes }); The first entry '/': { component: DemoComponent }, shall always exist, it's the default route loaded on start. It's being recognized by the '/' key (the position in the array doesn't matter). The entry '**': { component: DemoComponent } is optional and defines a fallback in case an invalid path is being used. You can shorten the property here, too: const components = [DemoComponent, AboutComponent, ContactComponent, MainComponent]; GlobalProvider.bootstrap({ components, routes }); Use Routes # To activate a router you need a hyperlink. The router's code looks for a click onto an anchor tag. An appropriate code snippet to use the routes looks like this: a href= #/ n-link Home /a a href= #/about n-link About /a a href= #/demo n-link Demo /a a href= #/contact n-link Contact /a div n-router-outlet /div The important part here is the n-link attribute. Using this you can distinguish between navigation links for routing and any other anchor tag. You can also use a button element or any other. Internally it's just a click -event that's handled and that checks for the attribute, then. Please note the hash sign (#). It's required. No code or strategies here, write it by yourself and then enjoy the very small footprint of the outcome. Pro Tip! Import the router definition and use additional fields to create a menu directly from router configuration. If you have some sort of CSS framework running, that provides support for menu navigation by classes, just add the class for the currently active element to the n-link attribute like this: a href= #/ n-link= active Home /a a href= #/about n-link= active About /a a href= #/demo n-link= active Demo /a a href= #/contact n-link= active Contact /a div n-router-outlet /div After this, by clicking the hyperlink, the class \"active\" will be added to the anchor tag. Any click on any n-link decorated tag will remove all these classes from all these elements, first. The class' name can differ and you can add multiple classes. It's treated as string internally. Named Routes # The underlying Route definition, the type Routes , allows two additional fields ( outlet and data ): const routes: Routes = { '/': { component: HomeComponent, outlet: 'main' }, '/docu': { component: DocuComponent, outlet: 'main', data: { notlocal: true} }, '/about': { component: AboutComponent, outlet: 'main' }, '/demo': { component: DemoComponent, outlet: 'main', '/router': { component: RouterComponent, outlet: 'main' }, '/router/page1': { component: Page1Component, outlet: 'router' }, '/router/page2': { component: Page2Component, outlet: 'router' }, '/router/page2/other': { component: Page2Component, outlet: 'other' }, '/router/page3/other': { component: Page3Component, outlet: 'other' }, '/contact': { component: ContactComponent } }; With outlet one can define a named outlet. If you use this, you must name all routes as there is no fallback currently. The route outlet might reside everywhere. It may look like this: div n-router-outlet= other /div If the route's components deliver li elements, you can also use something like this to build well formatted HTML: ul n-router-outlet= other /div There is no difference on the link side, the decision to address another outlet is made in the configuration only. If the outlet doesn't exists nothing happens and a warning appears on the console (in DEBUG mode). In the example I use routes that look like child routes. That's a hint for the intended behavior, but it's technically not necessary doing so. The resolver is very simple and doesn't care about routes, it's just matching the string and seeking the outlet. Additional Data # The last example showed another field data . This is a dictionary with arbitrary data just stored here. If you setup a navigation dynamically based on the configuration data you can control the behavior in a well defined way. However, There is no code intercepting these data, it's task of the implementer to do something useful here. If you use data: { title: 'Some Title' } the value in the field title is being copied to the websites title field. That way it appears on the tab (or header bar in Electron). If it's omitted, it's not being set at all. Navigate to Route # You can navigate by code: GlobalProvider.navigateRoute('/my-route'); The outlet is pulled from configuration, but if provided as second parameter it can be overwritten. Hint: In the link elements you use the '#' prefix. In the navigateRoute method this is not necessary and hence not allowed. Route Events # The router fires two events, available through the static GlobalProvider class like this: GlobalProvider.routerAction.addEventListener('navigate', (evt) = { const route = evt.detail; evt.cancel = true; // optionally cancel before execution } GlobalProvider.routerAction.addEventListener('navigated', (evt) = { const route = evt.detail; // this event can't be cancelled } If you have a dynamic component and you set the event handler, don't forget to remove the event handler in the dispose callback.","title":"Router"},{"location":"md/docs/lib/router/#router","text":"Usually we create SPAs (Single Page Apps). Hence we need a router. The included router is very simple. First, define an outlet where the components appear: div n-router-outlet /div Any kind of parent element will do. The router code sets the property innerHTML . Components, that are being used to provide router content need registration too. They must have a name, too, because that's the way the router internally activates the component. There is just one default outlet. See further below for using named outlets.","title":"Router"},{"location":"md/docs/lib/router/#register-routes","text":"The following code shows how to register routes: let routes = { '/': { component: DemoComponent }, '/about': { component: AboutComponent }, '/demo': { component: DemoComponent }, '/contact': { component: ContactComponent }, '**': { component: DemoComponent } }; GlobalProvider.bootstrap({ components: [DemoComponent, AboutComponent, ContactComponent, MainComponent], routes: routes }); The first entry '/': { component: DemoComponent }, shall always exist, it's the default route loaded on start. It's being recognized by the '/' key (the position in the array doesn't matter). The entry '**': { component: DemoComponent } is optional and defines a fallback in case an invalid path is being used. You can shorten the property here, too: const components = [DemoComponent, AboutComponent, ContactComponent, MainComponent]; GlobalProvider.bootstrap({ components, routes });","title":"Register Routes"},{"location":"md/docs/lib/router/#use-routes","text":"To activate a router you need a hyperlink. The router's code looks for a click onto an anchor tag. An appropriate code snippet to use the routes looks like this: a href= #/ n-link Home /a a href= #/about n-link About /a a href= #/demo n-link Demo /a a href= #/contact n-link Contact /a div n-router-outlet /div The important part here is the n-link attribute. Using this you can distinguish between navigation links for routing and any other anchor tag. You can also use a button element or any other. Internally it's just a click -event that's handled and that checks for the attribute, then. Please note the hash sign (#). It's required. No code or strategies here, write it by yourself and then enjoy the very small footprint of the outcome. Pro Tip! Import the router definition and use additional fields to create a menu directly from router configuration. If you have some sort of CSS framework running, that provides support for menu navigation by classes, just add the class for the currently active element to the n-link attribute like this: a href= #/ n-link= active Home /a a href= #/about n-link= active About /a a href= #/demo n-link= active Demo /a a href= #/contact n-link= active Contact /a div n-router-outlet /div After this, by clicking the hyperlink, the class \"active\" will be added to the anchor tag. Any click on any n-link decorated tag will remove all these classes from all these elements, first. The class' name can differ and you can add multiple classes. It's treated as string internally.","title":"Use Routes"},{"location":"md/docs/lib/router/#named-routes","text":"The underlying Route definition, the type Routes , allows two additional fields ( outlet and data ): const routes: Routes = { '/': { component: HomeComponent, outlet: 'main' }, '/docu': { component: DocuComponent, outlet: 'main', data: { notlocal: true} }, '/about': { component: AboutComponent, outlet: 'main' }, '/demo': { component: DemoComponent, outlet: 'main', '/router': { component: RouterComponent, outlet: 'main' }, '/router/page1': { component: Page1Component, outlet: 'router' }, '/router/page2': { component: Page2Component, outlet: 'router' }, '/router/page2/other': { component: Page2Component, outlet: 'other' }, '/router/page3/other': { component: Page3Component, outlet: 'other' }, '/contact': { component: ContactComponent } }; With outlet one can define a named outlet. If you use this, you must name all routes as there is no fallback currently. The route outlet might reside everywhere. It may look like this: div n-router-outlet= other /div If the route's components deliver li elements, you can also use something like this to build well formatted HTML: ul n-router-outlet= other /div There is no difference on the link side, the decision to address another outlet is made in the configuration only. If the outlet doesn't exists nothing happens and a warning appears on the console (in DEBUG mode). In the example I use routes that look like child routes. That's a hint for the intended behavior, but it's technically not necessary doing so. The resolver is very simple and doesn't care about routes, it's just matching the string and seeking the outlet.","title":"Named Routes"},{"location":"md/docs/lib/router/#additional-data","text":"The last example showed another field data . This is a dictionary with arbitrary data just stored here. If you setup a navigation dynamically based on the configuration data you can control the behavior in a well defined way. However, There is no code intercepting these data, it's task of the implementer to do something useful here. If you use data: { title: 'Some Title' } the value in the field title is being copied to the websites title field. That way it appears on the tab (or header bar in Electron). If it's omitted, it's not being set at all.","title":"Additional Data"},{"location":"md/docs/lib/router/#navigate-to-route","text":"You can navigate by code: GlobalProvider.navigateRoute('/my-route'); The outlet is pulled from configuration, but if provided as second parameter it can be overwritten. Hint: In the link elements you use the '#' prefix. In the navigateRoute method this is not necessary and hence not allowed.","title":"Navigate to Route"},{"location":"md/docs/lib/router/#route-events","text":"The router fires two events, available through the static GlobalProvider class like this: GlobalProvider.routerAction.addEventListener('navigate', (evt) = { const route = evt.detail; evt.cancel = true; // optionally cancel before execution } GlobalProvider.routerAction.addEventListener('navigated', (evt) = { const route = evt.detail; // this event can't be cancelled } If you have a dynamic component and you set the event handler, don't forget to remove the event handler in the dispose callback.","title":"Route Events"},{"location":"md/docs/lib/services/","text":"Services # Want to access an injectable service? @CustomElement('app-main') @InjectService('localNameA', ServiceClass1) @InjectService('localNameB', ServiceClass2, true) export class MainComponent extends BaseComponent {} { // ... omitted for brevity async render() { let data = await this.services('localNameA').callAnyServiceFunctionHereAsync(); } } Async is an option, can by sync, too. However, the render process is always asynchronous internally. this.services is a function, that returns an instance of the service. Services are singleton on the level of the local name. The same name used in different components will return the same instance. Using a different name will create a new instance. The third option of @InjectService allows to define a singleton. Instead of providing a type for the decorator, here you must provide an instance. The same name will be shared across components.","title":"Services"},{"location":"md/docs/lib/services/#services","text":"Want to access an injectable service? @CustomElement('app-main') @InjectService('localNameA', ServiceClass1) @InjectService('localNameB', ServiceClass2, true) export class MainComponent extends BaseComponent {} { // ... omitted for brevity async render() { let data = await this.services('localNameA').callAnyServiceFunctionHereAsync(); } } Async is an option, can by sync, too. However, the render process is always asynchronous internally. this.services is a function, that returns an instance of the service. Services are singleton on the level of the local name. The same name used in different components will return the same instance. Using a different name will create a new instance. The third option of @InjectService allows to define a singleton. Instead of providing a type for the decorator, here you must provide an instance. The same name will be shared across components.","title":"Services"},{"location":"md/docs/lib/setup/","text":"Setup # Now, because it's based on TypeScript, it's very recommended to use WebPack and TypeScript's configuration file tsconfig.json . The tsconfig.json looks like this: { compilerOptions : { target : es2015 , module : commonjs , moduleResolution : node , resolveJsonModule : true, sourceMap : true, lib : [ es2018 , es5 , dom ], jsx : react , declaration : true, reactNamespace : JSX , experimentalDecorators : true, noImplicitAny : false, suppressImplicitAnyIndexErrors : true, removeComments : false, outDir : out-tsc , baseUrl : src , typeRoots : [ node_modules/@types , src/types ] } } The webpack.config.json looks like this (with SCSS support and dev server): const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { app: './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] // }) }, // CSS loader { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; The package.json gets an entry in scripts section: build: webpack , Build # Now, on command line, just type npm run build . To start WebPack's dev server type: npm start An now enjoy writing a component based SPA with only 34 KB of lib code in total.","title":"Setup"},{"location":"md/docs/lib/setup/#setup","text":"Now, because it's based on TypeScript, it's very recommended to use WebPack and TypeScript's configuration file tsconfig.json . The tsconfig.json looks like this: { compilerOptions : { target : es2015 , module : commonjs , moduleResolution : node , resolveJsonModule : true, sourceMap : true, lib : [ es2018 , es5 , dom ], jsx : react , declaration : true, reactNamespace : JSX , experimentalDecorators : true, noImplicitAny : false, suppressImplicitAnyIndexErrors : true, removeComments : false, outDir : out-tsc , baseUrl : src , typeRoots : [ node_modules/@types , src/types ] } } The webpack.config.json looks like this (with SCSS support and dev server): const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { app: './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] // }) }, // CSS loader { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; The package.json gets an entry in scripts section: build: webpack ,","title":"Setup"},{"location":"md/docs/lib/setup/#build","text":"Now, on command line, just type npm run build . To start WebPack's dev server type: npm start An now enjoy writing a component based SPA with only 34 KB of lib code in total.","title":"Build"},{"location":"md/docs/lib/shadowdom/","text":"Shadow DOM # By default the shadow DOM is _not _ used. If it would, it would mean, that styles are isolated. No global styles are available, then. One option to activate the Shadow DOM: @ShadowDOM() The property can be set explicitly. The default is false , hence if the decorator is being omitted, the component is _not _ shadowed. @ShadowDOM(true | false) Another interesting option controls the style behavior: @UseParentStyles() The decorator ShadowDOM must be set, otherwise the decorator @UseParentStyle does nothing If active, it copies all global styles into component so they work as expected even in Shadow DOM It's a trade-off. Shadow DOM increases performance and brings isolation. Copying many styles decreases performance and contradicts isolation. Example: @CustomElement('app-contact') @ShadowDOM() @UseParentStyles() export class ContactComponent extends BaseComponent { // omitted for brevity } Shadow DOM goes well along with the usage of slots. A typical example is a Tabs Component, that could look like this: Example with Shadow DOM # First, the definition of a single tab. Tab # import JSX, { BaseComponent, CustomElement, ShadowDOM, UseParentStyles, LifeCycle } from '@nyaf/lib'; @CustomElement('app-slot-tab') @ShadowDOM(true) export class SlotTabComponent extends BaseComponent {} { private _title: string; constructor() { super(); this.classList.add('hide'); } async render() { return await ( div id={this.getAttribute('data-id')} slot /slot /div ); } public get title() { return this._title; } public set title(value) { this._title = value; } } The slot element is the content target. The id is used to address the tab (to open it, actually). Tabs # Now the container that handles multiple tabs. import JSX, { BaseComponent, CustomElement, LifeCycle, Events, ShadowDOM, UseParentStyles, uuidv4 } from '@nyaf/lib'; interface TabStore { node: Node; targetId: string; id: string; } interface IMaterialTabsDefaultConfig { materialtabsDeferred?: number; deep?: boolean; fixedTabs?: boolean; clsComponent?: string; clsTab?: string; clsTabActive?: string; clsMarker?: string; onBeforeTabOpen?(); onTabOpen?(); onTabsScroll?(); onTabsCreate?(); }; // tslint:disable-next-line:max-classes-per-file @CustomElement('app-slot-tabs') @Events(['all']) @ShadowDOM(true) @UseParentStyles(true) export class SlotTabsComponent extends BaseComponent {} { private tabChildren: TabStore[] = []; constructor() { super(); } async render() { let first = 0; const tabHeaders = Array.prototype.slice.call(this.children).map((child: Element) = { const targetId: string = child.id ?? '_' + uuidv4(); child.setAttribute('id', targetId); this.tabChildren.push({ node: child, targetId, id: child.id }); return ( li class='nav-item' a class={'nav-link ' + (0 === first++ ? 'active' : '')} href={`#${targetId}`} {child.getAttribute('title')} /a /li ); }); return await ( ul role= nav class= nav nav-tabs {tabHeaders} /ul div class='row' div class='col' slot /slot /div /div / ) } lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Load) { let first = 0; this.shadowRoot.querySelectorAll('li') .forEach(li = { li.addEventListener('click', (e: Event) = this.selectTab(e)); if (first === 0) { this.openTab(li.querySelector('a').getAttribute('href')); } first++; }); } } private selectTab(e: Event) { let targetId = (e.target as HTMLElement).getAttribute('href'); if (!targetId) { const innerA = (e.target as HTMLElement).querySelector('a'); if (innerA) { targetId = innerA.getAttribute('href'); } } this.openTab(targetId); e.preventDefault(); e.cancelBubble = true; return false; } async setTab(id: string): Promise void { const targetId = this.tabChildren.filter((child) = child.id === id).shift().targetId; // use shadowRoot because it is shadowed this.openTab(`#${targetId}`); return Promise.resolve(); } // the visible tabs are in the shadow-root, the content is outside in the document private openTab(targetId: string) { const tabs = this.shadowRoot.querySelectorAll('li a'); // const tab = this.querySelector HTMLElement (targetId); const a = this.shadowRoot.querySelector(`[href= ${targetId} ]`); // hide all const tabContent = this.querySelectorAll('app-slot-tab'); tabContent.forEach((t: HTMLElement) = { t.classList.add('d-none'); }); // deactivate all tabs.forEach(t = { t.classList.remove('active'); }); // activate a.classList.add('active'); // move the marker // make tabContent visible const currentTab = this.querySelector('app-slot-tab' + targetId); currentTab.classList.remove('d-none'); } } Usage # The usage is quite simple. Just add as many tabs as required: app-slot-tabs id='demoTabs' app-slot-tab title='Store Counter' id='d1' app-store-counter id='s1' cnt={42} /app-store-counter /app-slot-tab app-slot-tab title='Store Data' id='d2' app-store-data id='s2' /app-store-data /app-slot-tab /app-slot-tabs","title":"Shadow DOM"},{"location":"md/docs/lib/shadowdom/#shadow-dom","text":"By default the shadow DOM is _not _ used. If it would, it would mean, that styles are isolated. No global styles are available, then. One option to activate the Shadow DOM: @ShadowDOM() The property can be set explicitly. The default is false , hence if the decorator is being omitted, the component is _not _ shadowed. @ShadowDOM(true | false) Another interesting option controls the style behavior: @UseParentStyles() The decorator ShadowDOM must be set, otherwise the decorator @UseParentStyle does nothing If active, it copies all global styles into component so they work as expected even in Shadow DOM It's a trade-off. Shadow DOM increases performance and brings isolation. Copying many styles decreases performance and contradicts isolation. Example: @CustomElement('app-contact') @ShadowDOM() @UseParentStyles() export class ContactComponent extends BaseComponent { // omitted for brevity } Shadow DOM goes well along with the usage of slots. A typical example is a Tabs Component, that could look like this:","title":"Shadow DOM"},{"location":"md/docs/lib/shadowdom/#example-with-shadow-dom","text":"First, the definition of a single tab.","title":"Example with Shadow DOM"},{"location":"md/docs/lib/shadowdom/#tab","text":"import JSX, { BaseComponent, CustomElement, ShadowDOM, UseParentStyles, LifeCycle } from '@nyaf/lib'; @CustomElement('app-slot-tab') @ShadowDOM(true) export class SlotTabComponent extends BaseComponent {} { private _title: string; constructor() { super(); this.classList.add('hide'); } async render() { return await ( div id={this.getAttribute('data-id')} slot /slot /div ); } public get title() { return this._title; } public set title(value) { this._title = value; } } The slot element is the content target. The id is used to address the tab (to open it, actually).","title":"Tab"},{"location":"md/docs/lib/shadowdom/#tabs","text":"Now the container that handles multiple tabs. import JSX, { BaseComponent, CustomElement, LifeCycle, Events, ShadowDOM, UseParentStyles, uuidv4 } from '@nyaf/lib'; interface TabStore { node: Node; targetId: string; id: string; } interface IMaterialTabsDefaultConfig { materialtabsDeferred?: number; deep?: boolean; fixedTabs?: boolean; clsComponent?: string; clsTab?: string; clsTabActive?: string; clsMarker?: string; onBeforeTabOpen?(); onTabOpen?(); onTabsScroll?(); onTabsCreate?(); }; // tslint:disable-next-line:max-classes-per-file @CustomElement('app-slot-tabs') @Events(['all']) @ShadowDOM(true) @UseParentStyles(true) export class SlotTabsComponent extends BaseComponent {} { private tabChildren: TabStore[] = []; constructor() { super(); } async render() { let first = 0; const tabHeaders = Array.prototype.slice.call(this.children).map((child: Element) = { const targetId: string = child.id ?? '_' + uuidv4(); child.setAttribute('id', targetId); this.tabChildren.push({ node: child, targetId, id: child.id }); return ( li class='nav-item' a class={'nav-link ' + (0 === first++ ? 'active' : '')} href={`#${targetId}`} {child.getAttribute('title')} /a /li ); }); return await ( ul role= nav class= nav nav-tabs {tabHeaders} /ul div class='row' div class='col' slot /slot /div /div / ) } lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Load) { let first = 0; this.shadowRoot.querySelectorAll('li') .forEach(li = { li.addEventListener('click', (e: Event) = this.selectTab(e)); if (first === 0) { this.openTab(li.querySelector('a').getAttribute('href')); } first++; }); } } private selectTab(e: Event) { let targetId = (e.target as HTMLElement).getAttribute('href'); if (!targetId) { const innerA = (e.target as HTMLElement).querySelector('a'); if (innerA) { targetId = innerA.getAttribute('href'); } } this.openTab(targetId); e.preventDefault(); e.cancelBubble = true; return false; } async setTab(id: string): Promise void { const targetId = this.tabChildren.filter((child) = child.id === id).shift().targetId; // use shadowRoot because it is shadowed this.openTab(`#${targetId}`); return Promise.resolve(); } // the visible tabs are in the shadow-root, the content is outside in the document private openTab(targetId: string) { const tabs = this.shadowRoot.querySelectorAll('li a'); // const tab = this.querySelector HTMLElement (targetId); const a = this.shadowRoot.querySelector(`[href= ${targetId} ]`); // hide all const tabContent = this.querySelectorAll('app-slot-tab'); tabContent.forEach((t: HTMLElement) = { t.classList.add('d-none'); }); // deactivate all tabs.forEach(t = { t.classList.remove('active'); }); // activate a.classList.add('active'); // move the marker // make tabContent visible const currentTab = this.querySelector('app-slot-tab' + targetId); currentTab.classList.remove('d-none'); } }","title":"Tabs"},{"location":"md/docs/lib/shadowdom/#usage","text":"The usage is quite simple. Just add as many tabs as required: app-slot-tabs id='demoTabs' app-slot-tab title='Store Counter' id='d1' app-store-counter id='s1' cnt={42} /app-store-counter /app-slot-tab app-slot-tab title='Store Data' id='d2' app-store-data id='s2' /app-store-data /app-slot-tab /app-slot-tabs","title":"Usage"},{"location":"md/docs/lib/smart/","text":"Smart Components # Some features do not require additional code, they just need a clever usage of the power of TypeScript and Web Components. To simplify your life, a few of these are predefined as integrated components - the Smart Components. Repeater - n-repeat # The repeater component creates a loop. In the following example and interface defines a single item. An array with items of this type is provided. import JSX, { CustomElement, BaseComponent, of } from '@nyaf/lib'; interface T { id: number; name: string; } @CustomElement('app-repeater-test') export class RepeaterTestComponent extends BaseComponent {} { eventData: any; constructor() { super(); } clickMe(e) { console.log('Button Element Click ', e); this.eventData = e; super.setup(); } async render() { const data: Array T = [{ id: 1, name: 'One' }, { id: 2, name: 'Two' }, { id: 3, name: 'Three' }] return await ( div ul n-repeat source={data} li data={of T (p = p.id)} {of T (p = p.name)} /li /n-repeat /ul /div / ); } } The repeater repeats the array's elements. Each element provides properties you can place anywhere in the body using the of Type operator. It's type safe, the editor will help you selecting the right properties from the given type. Transparent Outlet n-outlet # This is another outlet that renders into nothing. Normally you would do this: div n-router-outlet /div But that would place your component in a DIV element. If this is disturbing, just use this: n-outlet /n-outlet Also, a named variety is available: n-outlet name= main /n-outlet","title":"Smart Components"},{"location":"md/docs/lib/smart/#smart-components","text":"Some features do not require additional code, they just need a clever usage of the power of TypeScript and Web Components. To simplify your life, a few of these are predefined as integrated components - the Smart Components.","title":"Smart Components"},{"location":"md/docs/lib/smart/#repeater-n-repeat","text":"The repeater component creates a loop. In the following example and interface defines a single item. An array with items of this type is provided. import JSX, { CustomElement, BaseComponent, of } from '@nyaf/lib'; interface T { id: number; name: string; } @CustomElement('app-repeater-test') export class RepeaterTestComponent extends BaseComponent {} { eventData: any; constructor() { super(); } clickMe(e) { console.log('Button Element Click ', e); this.eventData = e; super.setup(); } async render() { const data: Array T = [{ id: 1, name: 'One' }, { id: 2, name: 'Two' }, { id: 3, name: 'Three' }] return await ( div ul n-repeat source={data} li data={of T (p = p.id)} {of T (p = p.name)} /li /n-repeat /ul /div / ); } } The repeater repeats the array's elements. Each element provides properties you can place anywhere in the body using the of Type operator. It's type safe, the editor will help you selecting the right properties from the given type.","title":"Repeater - n-repeat"},{"location":"md/docs/lib/smart/#transparent-outlet-n-outlet","text":"This is another outlet that renders into nothing. Normally you would do this: div n-router-outlet /div But that would place your component in a DIV element. If this is disturbing, just use this: n-outlet /n-outlet Also, a named variety is available: n-outlet name= main /n-outlet","title":"Transparent Outlet n-outlet"},{"location":"md/docs/lib/template/","text":"Template Features # Template Features avoid using creepy JavaScript for interactions and branches. You can use: n-if , n-else n-hide , n-show n-on- event (see further down) n-expand n-if, n-else # The value will be evaluated and the element does or does not render, then: div class= main-header n-if={this.props.title !== 't1'} span Any content will not render if container doesn't render /span /div If there is an else-branch it can direct to a slot template. slot elements are native web component parts. div class= main-header n-if={this.props.title !== 't1'} n-else= noShow span Any content will not render if container doesn't render /span /div slot name= noShow This is shown instead. /slot n-hide, n-show # Works same as n-if , but just adds an inline style display: none (or remove one) if true ( n-hide ) or false ( n-show ). n-expand # Expand a group of attributes. Imagine this: input type= text placeholder= Name role= search class= materialinput id= a1 / You need this several times, each with different id. input n-expand= search id= a1 / input n-expand= search id= a2 / input n-expand= search id= a3 / To define it, just create a class like this: @Expand( search ) export class SearchExpander extends Expander { constructor(){ super(); } 'type'= text ; 'placeholder'= Name ; 'role'= search ; 'class'= materialinput ; } Any yes, these are equal signs in the class. The named 'xxx' names are only required if the attribute name contains dashes. Finally, add the definition to the global provider: Globalprovider.bootstrap({ components: [...components], // as usual expanders: [SearchExpander] }) That's it, a lot less to write without the effort to create components. It's just text-replacement before the render grabs the content, so NO performance impact at runtime. Quick Expanders # This is even easier, but more for local expanding: const d = { 'type': text ; 'placeholder': Name ; 'role': search ; 'class': materialinput ; } app-button {...d} / It's just pure ECMAScript magic, no code from @nyaf required. n-repeat # The basic idea of TSX is to write traditional code using map or forEach on array to create loops. In most cases this is the best solution. It provides editor support and you can add the full range of JavaScript API features to adjust the result. But sometimes a simple loop is required and the creation of a complete expression creates a lot boilerplate code. In that case two variations of loops are provided, both with full editor support, too. Syntax I - n-repeat component # This is a smart component that acts as a helper for common tasks. It's supported by one functions for binding: of : Creates an expression to select a property from a model. The only reason is to have editor support (IntelliSense) without additional tools. ul n-repeat source={this.eventData} li data={of TBind (p = p.id)} {of TBind (p = p.name)} /li /n-repeat /ul Also, a @nyaf template function with the same name exists. This is supported by two other function for same reason: from : Define a data source for repeating; must be an array of objects. select : Select a property from the object type the array consists of. ul li n-repeat={from TBind (this.eventData)} data={select TBind (p = p.id)} The name is: {select TBind (p = p.name)} /li /ul Both examples would work with a type definition like this: interface TBind { id: number; name: string; } In the component the data assignment looks like this: // excerpt from a component private eventData: Array TBind ; constructor() { super(); this.eventData = [{ id: 1, name: 'One' }, { id: 2, name: 'Two' }, { id: 3, name: 'Three' }]; }","title":"Template Language"},{"location":"md/docs/lib/template/#template-features","text":"Template Features avoid using creepy JavaScript for interactions and branches. You can use: n-if , n-else n-hide , n-show n-on- event (see further down) n-expand","title":"Template Features"},{"location":"md/docs/lib/template/#n-if-n-else","text":"The value will be evaluated and the element does or does not render, then: div class= main-header n-if={this.props.title !== 't1'} span Any content will not render if container doesn't render /span /div If there is an else-branch it can direct to a slot template. slot elements are native web component parts. div class= main-header n-if={this.props.title !== 't1'} n-else= noShow span Any content will not render if container doesn't render /span /div slot name= noShow This is shown instead. /slot","title":"n-if, n-else"},{"location":"md/docs/lib/template/#n-hide-n-show","text":"Works same as n-if , but just adds an inline style display: none (or remove one) if true ( n-hide ) or false ( n-show ).","title":"n-hide, n-show"},{"location":"md/docs/lib/template/#n-expand","text":"Expand a group of attributes. Imagine this: input type= text placeholder= Name role= search class= materialinput id= a1 / You need this several times, each with different id. input n-expand= search id= a1 / input n-expand= search id= a2 / input n-expand= search id= a3 / To define it, just create a class like this: @Expand( search ) export class SearchExpander extends Expander { constructor(){ super(); } 'type'= text ; 'placeholder'= Name ; 'role'= search ; 'class'= materialinput ; } Any yes, these are equal signs in the class. The named 'xxx' names are only required if the attribute name contains dashes. Finally, add the definition to the global provider: Globalprovider.bootstrap({ components: [...components], // as usual expanders: [SearchExpander] }) That's it, a lot less to write without the effort to create components. It's just text-replacement before the render grabs the content, so NO performance impact at runtime.","title":"n-expand"},{"location":"md/docs/lib/template/#quick-expanders","text":"This is even easier, but more for local expanding: const d = { 'type': text ; 'placeholder': Name ; 'role': search ; 'class': materialinput ; } app-button {...d} / It's just pure ECMAScript magic, no code from @nyaf required.","title":"Quick Expanders"},{"location":"md/docs/lib/template/#n-repeat","text":"The basic idea of TSX is to write traditional code using map or forEach on array to create loops. In most cases this is the best solution. It provides editor support and you can add the full range of JavaScript API features to adjust the result. But sometimes a simple loop is required and the creation of a complete expression creates a lot boilerplate code. In that case two variations of loops are provided, both with full editor support, too.","title":"n-repeat"},{"location":"md/docs/lib/template/#syntax-i-n-repeat-component","text":"This is a smart component that acts as a helper for common tasks. It's supported by one functions for binding: of : Creates an expression to select a property from a model. The only reason is to have editor support (IntelliSense) without additional tools. ul n-repeat source={this.eventData} li data={of TBind (p = p.id)} {of TBind (p = p.name)} /li /n-repeat /ul Also, a @nyaf template function with the same name exists. This is supported by two other function for same reason: from : Define a data source for repeating; must be an array of objects. select : Select a property from the object type the array consists of. ul li n-repeat={from TBind (this.eventData)} data={select TBind (p = p.id)} The name is: {select TBind (p = p.name)} /li /ul Both examples would work with a type definition like this: interface TBind { id: number; name: string; } In the component the data assignment looks like this: // excerpt from a component private eventData: Array TBind ; constructor() { super(); this.eventData = [{ id: 1, name: 'One' }, { id: 2, name: 'Two' }, { id: 3, name: 'Three' }]; }","title":"Syntax I - n-repeat component"},{"location":"md/docs/store/example/","text":"Type Handling in Typescript # The store has these basic parts as described before: Actions Reducer Store and Store Types The Actions are basically string constants. The reducers get payload that's anything. The return value is the Store Type. The store has two basic function: dispatch subscribe You dispatch an Action along with a payload. So, the types are string and any . When you receive a store event from a subscribe this subscription watches for changes of a part of the Store Type. The event handler receives the whole store, then. Example # Assume we deal with a CRUD component using a custom model like this: import { Display } from @nyaf/forms ; import { TemplateHint } from @nyaf/forms ; import { Sortable } from @nyaf/forms ; import { Hidden } from @nyaf/forms ; export class ArchivModel { @Hidden() id: number = 0; @Display('Closet') @Sortable() @TemplateHint('table-column', { 'width': 50 }) Closet: string = ''; @Display('Name') @Sortable() @TemplateHint('table-column', { 'width': 100 }) Name: string= ''; @Display('Surname') @Sortable() @TemplateHint('table-column', { 'width': 100 }) Surname: string = ''; @Display('Birthday') @TemplateHint('table-column', { 'width': 100 }) Birthday: string = ''; @Display('Number of Files') @TemplateHint('table-column', { 'width': 30 }) NoFiles: number = 1; @Display('Archived') @Sortable() @TemplateHint('table-column', { 'width': 50 }) ArchivedYear: number = 2010; } The decorators are from the @nyaf/forms project. Now, some actions are required: import { ArchivModel } from ../model/archiv.model ; export const ALL = 'ALL'; export const EDIT = 'EDIT'; export const ADD = 'ADD'; export const SAVE = 'SAVE'; export const REMOVE = 'REMOVE'; /** * The defaults that we use as long as the code hasn't sent anything. */ export default { [ALL]: () = '', [EDIT]: () = new ArchivModel(), [ADD]: () = new ArchivModel(), [SAVE]: () = new ArchivModel(), [REMOVE]: () = 0 }; Also, some reducers doing the hard work: import { ALL, ADD, REMOVE, EDIT, SAVE } from '../actions/archive.actions'; import { archiveStoreType } from '../stores/archive.store'; import { DatabaseService } from 'app/services/database.service'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; import { ArchivModel } from '../model/archiv.model'; import * as $sql from 'app/resources/sql.json'; /** * The reducer functions are the executing logic. They do what the action is asking for. */ export default { [ALL]: async (state: archiveStoreType, payload: string) = { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigen); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; }, [EDIT]: async (state: archiveStoreType, payload: number) = { const [current]: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigenAktuelles, payload); state.current = current; return state; }, [ADD]: (state: archiveStoreType, payload: ArchivModel) = { state.current = null; return state; }, [SAVE]: async (state: archiveStoreType, payload: ArchivModel) = { const data: any = await DatabaseService.instance.instance.exec( payload.id ? $sql.ArchivUpdate : $sql.ArchivInsert, payload.Schrank, payload.Vorname, payload.Nachname, payload.Geburtsdatum, payload.AnzahlAkten, payload.ArchivJahr, payload.id ); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; }, [REMOVE]: async (state: archiveStoreType, payload: number) = { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivEntfernenFinal, payload); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; } }; DatabaseService.instance.instance is a service class with singleton pattern. It executes SQL. $sql provides the statements from a resource file. THe store summarizes all this for easy processing: import { ArchivModel } from ../model/archiv.model ; import { DataGridModel } from app/components/shared/grid/models/datagrid.model ; export interface ArchiveStore { current: ArchivModel; gridResult: DataGridModel ArchivModel ; } /** * A store contains a data structure that helds up to the entire app's state. * It can have any complexity, from a single value up to deep nested objects. */ export interface ActionStore { search: string; } /** * We export a single store type that contains all single stores as one default. */ export type archiveStoreType = ActionStore ArchiveStore; import archiveReducer from '../reducer/archive.reducer'; import archiveActions, { SEARCH, ADD, REMOVE, ALL, ARCHIVED, EDIT } from '../actions/archive.actions'; import { Store } from @nyaf/store ; const store = new Store archiveStoreType ({ actions: archiveActions, reducer: { ...archiveReducer }, state: { search: '', current: null, gridResult: null } }); export default store; Now, the component can dispatch actions with payloads and receive store changes. @CustomElement( tab-archive-search ) @ProvideStore archiveStoreType (store) export class ArchiveSearchComponent extends StoreComponent archiveStoreType, {} { constructor() { super(); this.store.subscribe('gridResult', (data: archiveStoreType) = { // Do something with the data }); } private async showAll(e?: Event) { this.store.dispatch(ALL, null); } // render omitted for brevity } The reducer receives the ALL action. It pulls all the data and sets the gridResult object. The subscriber listens for this and can handle the data (re-render, for example). The essential part is here that the return value of the subscriber is always the Store Type (here archiveStoreType ). So you don't need to think about the current type and TypeScript resolves the types within properly. However, the subscriber is for just one property of the store and only changes of this property will trigger the handler. To get the data, access it like this: archiveStoreType.gridResult The underlying object is Proxy , not your actual type.","title":"Store Example"},{"location":"md/docs/store/example/#type-handling-in-typescript","text":"The store has these basic parts as described before: Actions Reducer Store and Store Types The Actions are basically string constants. The reducers get payload that's anything. The return value is the Store Type. The store has two basic function: dispatch subscribe You dispatch an Action along with a payload. So, the types are string and any . When you receive a store event from a subscribe this subscription watches for changes of a part of the Store Type. The event handler receives the whole store, then.","title":"Type Handling in Typescript"},{"location":"md/docs/store/example/#example","text":"Assume we deal with a CRUD component using a custom model like this: import { Display } from @nyaf/forms ; import { TemplateHint } from @nyaf/forms ; import { Sortable } from @nyaf/forms ; import { Hidden } from @nyaf/forms ; export class ArchivModel { @Hidden() id: number = 0; @Display('Closet') @Sortable() @TemplateHint('table-column', { 'width': 50 }) Closet: string = ''; @Display('Name') @Sortable() @TemplateHint('table-column', { 'width': 100 }) Name: string= ''; @Display('Surname') @Sortable() @TemplateHint('table-column', { 'width': 100 }) Surname: string = ''; @Display('Birthday') @TemplateHint('table-column', { 'width': 100 }) Birthday: string = ''; @Display('Number of Files') @TemplateHint('table-column', { 'width': 30 }) NoFiles: number = 1; @Display('Archived') @Sortable() @TemplateHint('table-column', { 'width': 50 }) ArchivedYear: number = 2010; } The decorators are from the @nyaf/forms project. Now, some actions are required: import { ArchivModel } from ../model/archiv.model ; export const ALL = 'ALL'; export const EDIT = 'EDIT'; export const ADD = 'ADD'; export const SAVE = 'SAVE'; export const REMOVE = 'REMOVE'; /** * The defaults that we use as long as the code hasn't sent anything. */ export default { [ALL]: () = '', [EDIT]: () = new ArchivModel(), [ADD]: () = new ArchivModel(), [SAVE]: () = new ArchivModel(), [REMOVE]: () = 0 }; Also, some reducers doing the hard work: import { ALL, ADD, REMOVE, EDIT, SAVE } from '../actions/archive.actions'; import { archiveStoreType } from '../stores/archive.store'; import { DatabaseService } from 'app/services/database.service'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; import { ArchivModel } from '../model/archiv.model'; import * as $sql from 'app/resources/sql.json'; /** * The reducer functions are the executing logic. They do what the action is asking for. */ export default { [ALL]: async (state: archiveStoreType, payload: string) = { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigen); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; }, [EDIT]: async (state: archiveStoreType, payload: number) = { const [current]: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigenAktuelles, payload); state.current = current; return state; }, [ADD]: (state: archiveStoreType, payload: ArchivModel) = { state.current = null; return state; }, [SAVE]: async (state: archiveStoreType, payload: ArchivModel) = { const data: any = await DatabaseService.instance.instance.exec( payload.id ? $sql.ArchivUpdate : $sql.ArchivInsert, payload.Schrank, payload.Vorname, payload.Nachname, payload.Geburtsdatum, payload.AnzahlAkten, payload.ArchivJahr, payload.id ); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; }, [REMOVE]: async (state: archiveStoreType, payload: number) = { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivEntfernenFinal, payload); const modelData = new DataGridModel ArchivModel (data, ArchivModel); state.gridResult = modelData; return state; } }; DatabaseService.instance.instance is a service class with singleton pattern. It executes SQL. $sql provides the statements from a resource file. THe store summarizes all this for easy processing: import { ArchivModel } from ../model/archiv.model ; import { DataGridModel } from app/components/shared/grid/models/datagrid.model ; export interface ArchiveStore { current: ArchivModel; gridResult: DataGridModel ArchivModel ; } /** * A store contains a data structure that helds up to the entire app's state. * It can have any complexity, from a single value up to deep nested objects. */ export interface ActionStore { search: string; } /** * We export a single store type that contains all single stores as one default. */ export type archiveStoreType = ActionStore ArchiveStore; import archiveReducer from '../reducer/archive.reducer'; import archiveActions, { SEARCH, ADD, REMOVE, ALL, ARCHIVED, EDIT } from '../actions/archive.actions'; import { Store } from @nyaf/store ; const store = new Store archiveStoreType ({ actions: archiveActions, reducer: { ...archiveReducer }, state: { search: '', current: null, gridResult: null } }); export default store; Now, the component can dispatch actions with payloads and receive store changes. @CustomElement( tab-archive-search ) @ProvideStore archiveStoreType (store) export class ArchiveSearchComponent extends StoreComponent archiveStoreType, {} { constructor() { super(); this.store.subscribe('gridResult', (data: archiveStoreType) = { // Do something with the data }); } private async showAll(e?: Event) { this.store.dispatch(ALL, null); } // render omitted for brevity } The reducer receives the ALL action. It pulls all the data and sets the gridResult object. The subscriber listens for this and can handle the data (re-render, for example). The essential part is here that the return value of the subscriber is always the Store Type (here archiveStoreType ). So you don't need to think about the current type and TypeScript resolves the types within properly. However, the subscriber is for just one property of the store and only changes of this property will trigger the handler. To get the data, access it like this: archiveStoreType.gridResult The underlying object is Proxy , not your actual type.","title":"Example"},{"location":"md/docs/store/globloc/","text":"Global and Local Store # Technically there is just one store. But logically you will usually split the access into a global store (per app or module) and a local one - per component. Merge Strategy # Within a component the stores are being merged and appears as one unit afterwards.","title":"Global and Local Stores"},{"location":"md/docs/store/globloc/#global-and-local-store","text":"Technically there is just one store. But logically you will usually split the access into a global store (per app or module) and a local one - per component.","title":"Global and Local Store"},{"location":"md/docs/store/globloc/#merge-strategy","text":"Within a component the stores are being merged and appears as one unit afterwards.","title":"Merge Strategy"},{"location":"md/docs/store/overview/","text":"The Flux Store # This module is the store implementation, a simple flux variant without the burden of Redux. It strictly follows the flux pattern and brings, ones fully understood, a great amount of strict programming style to your application. It brings state to your single page app (SPA). Outside of a SPA it's not useful. How it works # It's very much like Redux, but makes use of decorators to write less code. It's a good strategy to create one global store in your app. Leave it empty if there are no global actions, but make it global. Then, define three parts for each component: Actions that the component offers (such as SEARCH, LOAD, SET, REMOVE, you name it) Reducers that are pure function calls that do what your business logic requires (change data, call services) A State Object that holds all the data. The reducer can change the state, but nobody else can In the component you have two tasks: Dispatch actions and add payload if required. Listen for changes in the store to know when an reducer finished it's task An async load must not be splitted up. The calls are async, hence the state change may appear later, but nonetheless it lands in the component eventually. Actions # Define the capabilities of your app, along with some default or initial value. In this example I use Symbol to define unique constants that are being used for any further request of an action. export const INC = 'INC'; export const DEC = 'DEC'; export const SET = 'SET'; export default { [INC]: () = 1, // initial value of payload, this can be omitted if you don't care [DEC]: () = -1, SET }; The following figure shows the relevant parts of the action definition: Why using actions? It's convenient to have typed constants in the editor and use easy to remember names without the chance to create mistakenly typos. Reducer # Define, what happens if an action is being dispatched: import { INC, DEC } from '../actions/counter.action'; import stateType from '../states/counter.state'; export default { [INC]: (state: stateType, payload: number) = { state.counter = state.counter + payload; return state; }, [DEC]: (state: stateType, payload: number) = { state.counter = state.counter - payload; return state; } }; The following figure shows the relevant parts of the reducer definition: The returned payload is the whole store object by reference. The type for the store is optional and helps elevating the power of TypeScript and getting a type safe store. Why using reducers? Pure function calls are the foundation of a side effect free business layer. You have exactly one location where the logic goes - the reducer. That's said, from now omn you will know where to have logic, where to have UI, and where to store everything. Reducers can be sync or async, every function can be made as you like. Return Value Considerations # The return value is an object that contains the fragments of the store that need to be changed. Through subscriptions this is the way to inform other instances that something happened. But be careful with setting multiple values in one single step. The store logic will execute property by property and immediately publish the change event. A subscriber will receive the changes in the exact order of the properties in the reducers returns value. If the subscriber receives the first property's change event, the ne value is provided. However, the remaining values are not yet set, and hence the store is in an intermediate state. You must wait for all subscribers to get their final values. the best way to avoid hassle here is to avoid returning multiple values from single reducer function. Store and Dispatcher # The store holds the state, provides a dispatch function and fires events in case a store value changes. First, the store can by defined by types, but this is an option and you may decide to go with a simple object just for the sake of simplicity. The example shows a store that consists of fragments. This allows one to use parts of the store just by using the type fragments. // This is a store fragment export interface DemoTitleStore { title: string; } // This is a store fragment export interface CounterStore { counter: number; } // This is the complete store, which can be used complete or in fragments type store = CounterStore DemoTitleStore; // This is for convenient access export default store; Now the usage within a component. First, you must configure the store with the elements written before. As shown it's easy to combine reducers and add the various actions. To have the state typed a generic is being used. import counterReducer from '../reducer/counter.reducer'; import setReducer from '../reducer/set.reducer'; import counterActions from '../actions/counter.action'; import storeStateType from '../states/counter.state'; const store = new Store storeStateType ({ actions: counterActions, mutations: { ...counterReducer, ...setReducer }, state: { counter: 0 } }); Use the Store # Now make the store constant available in the component, if it's not yet defined there. This store can handle just on single component or spread multiple components and form eventually a single source of truth for the whole application. @CustomElement('app-store-counter') @ProvideStore storeStateType (store) export class StoreCounterComponent extends BaseComponent { cnt: number } implements IStore storeStateType { constructor() { super(); this.setData('cnt', 0); // fire if a value changes in the store, takes name of the store value this.store.subscribe('counter', str = { // write to a observed property to force re-render this.data.cnt = str.counter; }); } clickMeAdd(e) { console.log('Counter Element Click INC'); this.store.dispatch(INC, 1); } clickMeSub(e) { console.log('Counter Element Click DEC'); this.store.dispatch(DEC, 1); } clickMeSet(e) { console.log('Counter Element Click SET'); this.store.dispatch(SET, 100); } render() { return ( div button type='button' n-on-click={this.clickMeAdd} Add 1 /button button type='button' n-on-click={this.clickMeSub} Sub 1 /button button type='button' n-on-click={this.clickMeSet} Set 100 /button /div pre style='border: 1px solid gray;' {this.data.cnt} /pre / ); } } Tip! Combine this example with the forms module ( @nyaf/forms ) and get binding on element level using the n-bind template feature.","title":"Overview"},{"location":"md/docs/store/overview/#the-flux-store","text":"This module is the store implementation, a simple flux variant without the burden of Redux. It strictly follows the flux pattern and brings, ones fully understood, a great amount of strict programming style to your application. It brings state to your single page app (SPA). Outside of a SPA it's not useful.","title":"The Flux Store"},{"location":"md/docs/store/overview/#how-it-works","text":"It's very much like Redux, but makes use of decorators to write less code. It's a good strategy to create one global store in your app. Leave it empty if there are no global actions, but make it global. Then, define three parts for each component: Actions that the component offers (such as SEARCH, LOAD, SET, REMOVE, you name it) Reducers that are pure function calls that do what your business logic requires (change data, call services) A State Object that holds all the data. The reducer can change the state, but nobody else can In the component you have two tasks: Dispatch actions and add payload if required. Listen for changes in the store to know when an reducer finished it's task An async load must not be splitted up. The calls are async, hence the state change may appear later, but nonetheless it lands in the component eventually.","title":"How it works"},{"location":"md/docs/store/overview/#actions","text":"Define the capabilities of your app, along with some default or initial value. In this example I use Symbol to define unique constants that are being used for any further request of an action. export const INC = 'INC'; export const DEC = 'DEC'; export const SET = 'SET'; export default { [INC]: () = 1, // initial value of payload, this can be omitted if you don't care [DEC]: () = -1, SET }; The following figure shows the relevant parts of the action definition: Why using actions? It's convenient to have typed constants in the editor and use easy to remember names without the chance to create mistakenly typos.","title":"Actions"},{"location":"md/docs/store/overview/#reducer","text":"Define, what happens if an action is being dispatched: import { INC, DEC } from '../actions/counter.action'; import stateType from '../states/counter.state'; export default { [INC]: (state: stateType, payload: number) = { state.counter = state.counter + payload; return state; }, [DEC]: (state: stateType, payload: number) = { state.counter = state.counter - payload; return state; } }; The following figure shows the relevant parts of the reducer definition: The returned payload is the whole store object by reference. The type for the store is optional and helps elevating the power of TypeScript and getting a type safe store. Why using reducers? Pure function calls are the foundation of a side effect free business layer. You have exactly one location where the logic goes - the reducer. That's said, from now omn you will know where to have logic, where to have UI, and where to store everything. Reducers can be sync or async, every function can be made as you like.","title":"Reducer"},{"location":"md/docs/store/overview/#return-value-considerations","text":"The return value is an object that contains the fragments of the store that need to be changed. Through subscriptions this is the way to inform other instances that something happened. But be careful with setting multiple values in one single step. The store logic will execute property by property and immediately publish the change event. A subscriber will receive the changes in the exact order of the properties in the reducers returns value. If the subscriber receives the first property's change event, the ne value is provided. However, the remaining values are not yet set, and hence the store is in an intermediate state. You must wait for all subscribers to get their final values. the best way to avoid hassle here is to avoid returning multiple values from single reducer function.","title":"Return Value Considerations"},{"location":"md/docs/store/overview/#store-and-dispatcher","text":"The store holds the state, provides a dispatch function and fires events in case a store value changes. First, the store can by defined by types, but this is an option and you may decide to go with a simple object just for the sake of simplicity. The example shows a store that consists of fragments. This allows one to use parts of the store just by using the type fragments. // This is a store fragment export interface DemoTitleStore { title: string; } // This is a store fragment export interface CounterStore { counter: number; } // This is the complete store, which can be used complete or in fragments type store = CounterStore DemoTitleStore; // This is for convenient access export default store; Now the usage within a component. First, you must configure the store with the elements written before. As shown it's easy to combine reducers and add the various actions. To have the state typed a generic is being used. import counterReducer from '../reducer/counter.reducer'; import setReducer from '../reducer/set.reducer'; import counterActions from '../actions/counter.action'; import storeStateType from '../states/counter.state'; const store = new Store storeStateType ({ actions: counterActions, mutations: { ...counterReducer, ...setReducer }, state: { counter: 0 } });","title":"Store and Dispatcher"},{"location":"md/docs/store/overview/#use-the-store","text":"Now make the store constant available in the component, if it's not yet defined there. This store can handle just on single component or spread multiple components and form eventually a single source of truth for the whole application. @CustomElement('app-store-counter') @ProvideStore storeStateType (store) export class StoreCounterComponent extends BaseComponent { cnt: number } implements IStore storeStateType { constructor() { super(); this.setData('cnt', 0); // fire if a value changes in the store, takes name of the store value this.store.subscribe('counter', str = { // write to a observed property to force re-render this.data.cnt = str.counter; }); } clickMeAdd(e) { console.log('Counter Element Click INC'); this.store.dispatch(INC, 1); } clickMeSub(e) { console.log('Counter Element Click DEC'); this.store.dispatch(DEC, 1); } clickMeSet(e) { console.log('Counter Element Click SET'); this.store.dispatch(SET, 100); } render() { return ( div button type='button' n-on-click={this.clickMeAdd} Add 1 /button button type='button' n-on-click={this.clickMeSub} Sub 1 /button button type='button' n-on-click={this.clickMeSet} Set 100 /button /div pre style='border: 1px solid gray;' {this.data.cnt} /pre / ); } } Tip! Combine this example with the forms module ( @nyaf/forms ) and get binding on element level using the n-bind template feature.","title":"Use the Store"},{"location":"md/docs/store/setup/","text":"Installation # Install the store package like this: npm i @nyaf/store -S The one and only dependency is the core library, @nyaf/lib .","title":"Setup"},{"location":"md/docs/store/setup/#installation","text":"Install the store package like this: npm i @nyaf/store -S The one and only dependency is the core library, @nyaf/lib .","title":"Installation"}]}